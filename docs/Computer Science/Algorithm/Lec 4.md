# Algorithms II

## 六、NP-Completeness

!!! Info "参考"

    - wyy 的 ADS 讲义；
    - [Lawrence 大学的相关讲义](https://www2.lawrence.edu/fast/GREGGJ/CMSC515/chapt07/NPC.html)。

### 1. 形式语言

为了形式化定义问题与计算模型，我们首先给出某种编码，这就是形式语言干的事情。

- **字母表/Alphabet**：一个**至多可数**的集合 $\Sigma$；
- **字符串/String**：某个字母表上有限个元素的有序连接，所有这样的字符串记作 $\Sigma^*$，注意到 $\Sigma^*$ 其实是一个可数的集合；
- **形式语言/Formal Language**：某个字母表 $\Sigma$ 上所有的字符串 $\Sigma^*$ 的一个子集 $L$。

!!! Info "和 PPT 的不同"
    这部分是按照 wyy 的讲义写的，而 PPT 对字母表的定义是一个**有限**的集合，这里是一个**至多可数**的集合。这样的定义在我们的语境下没有什么影响，而且至多可数和后面讨论的逻辑系统可以联系起来。

形式语言可以做衔接/Concatenation、并/Union、交/Intersection、补/Complement、闭包/Kleene star 等运算，同时补充定义空串 $\varepsilon$，空语言 $\varnothing$，则这些运算的定义如下：

- 交和并运算：$L_1 \cap L_2 = \{ x : x \in L_1 \text{ and } x \in L_2 \}$，$L_1 \cup L_2 = \{ x : x \in L_1 \text{ or } x \in L_2 \}$；
- 补运算：$\overline{L} = \Sigma^* - L = \{ x : x \in \Sigma^* \text{ and } x \notin L \}$；
- 衔接运算：$L = \{ x_1x_2 : x_1 \in L_1 \text{ and } x_2 \in L_2 \}$；
- 幂运算（基于衔接运算）：$L^k = \{ x_1x_2 \cdots x_k : x_i \in L \}$；
- Kleene 星运算：$L^* = \{ \varepsilon \} \cup L \cup L^2 \cup L^3 \cup \cdots$。

我们主要处理三种问题：

- 给定语言 $L$，判断某个字符串 $\omega$ 是否在 $L$ 中，这被称为判定问题/decision problem；
- 给定语言 $L$，寻找某个字符串 $\omega$ 使得 $\omega$ 在 $L$ 中，这被称为搜索问题/search problem；
- 给定语言 $L_1, L_2$，计算某个从 $L_1$ 到 $L_2$ 的函数。

我们给出一个将自然语言下的问题转化成形式语言的判定问题的例子，显然，能够翻译的问题只有那些答案是“是”或者“否”的问题。我们考虑哈密顿回路问题：给定一个图，判断其是否有 Hamilton 回路。

首先，我们注意到所有图构成的集合是可数的：显然图的顶点数目有限，固定顶点数目的图的数量有限，可数个有限集的并集是可数集，所以所有图构成的集合是可数集。

其次，我们构造一个字母表 $\Sigma$，使得 $\Sigma^*$ 包含所有图而不包含其他东西。由于所有图是可数的，我们建立一个图和自然数的编号，进而只需要考虑自然数和 $\Sigma^*$ 的映射问题。我们直接令 $\Sigma = \{1\}$，这样字符串由几个 1 组成就意味着它是编号为几的图。于是我们的形式语言 $L$ 就定义为所有有 Hamilton 回路的图对应的字符串构成的集合。令**谓词/Predicate** $Q(x)$ 表示“$x$ 是一个有 Hamilton 回路的图”，则我们的判定问题就是给定一个字符串 $x$，判断其是否在 $L$ 中。这样的形式语言就可以写成

$$
L = \{x \in \Sigma^* : Q(x)\}
$$

从 PPT 上的另一个例子看形式语言，我们定义抽象问题/Abstract Problem $Q$ 为问题实例的集合 $I$ 和问题解 $S$ 的二元关系，又由于所有像最短路问题的这种最优化问题都可以在多项式时间内转化成判定问题，所以我们只需要考虑判定问题，因此判定路径问题就转变成了：

- 实例为 $I = \{\langle G, u, v, k\rangle : G = (V, E) \text{ is an undirected graph, } u, v \in V, k \in \mathbb{N}\}$；
- 解为 $S = \{0, 1\}$；
- 对所有实例 $i \in I$，$\mathrm{PATH}(i) = 1 \text{ or } 0$。

我们将实例映射成字母表为 $\Sigma = \{0, 1\}$ 的字符串。

对于算法 $A$ 和形式语言的关系，我们有下面的内容：

- 对于一个字符串 $x\in \Sigma^*$，如果 $A(x) = 1$，就称 $A$ **接受**这个字符串 $x$；
- 如果对于一个字符串 $x$，$A(x) = 0$，就称 $A$ **拒绝**这个字符串 $x$；
- 如果每一个形式语言 $L$ 的字符串 $x$ 都可以被 $A$ 接受并且不在形式语言 $L$ 内的字符串都被 $A$ 拒绝，就称形式语言 $L$ 被算法 $A$ 判定；

有了问题实例到字符串的映射关系，我们就可以提前定义后来的 $\mathsf{P}$ 问题：

$$
\mathsf{P} = \{ L \subseteq \Sigma^* : \text{there exists a polynomial-time algorithm } A \text{ that decides } L \}.
$$

我们在之后会更形式化定义这些复杂度类，尤其是需要引入核心的图灵机模型。

### 2. 计算模型

**确定性图灵机**：考虑一个**双向无限**的磁带/Tape，将磁带划分成一个一个的方格/Cell，有一个磁头/Head，磁头中有一个有限状态机，其中包含有限个状态 $q \in Q$。每个方格要么是空的/$\square$，要么就写有某个有限的字符集 $S$ 的字符。在每一步操作中，它可以完成：

- 磁头内部状态的转变；
- 把扫描到的符号 $s$ 改写成 $s' \in S \cup \{\square\}$；
- 往左/L 或往右/R 移动磁头。

每一步的改变都是由一个**偏函数** $\delta : Q \times (S \cup \{\square\}) \to Q \times (S \cup \{\square\}) \times \{L, R\}$ 决定的，我们将这个偏函数称为**图灵程序/Turing program**。

每一个计算开始之前，我们都将磁头置于起始方格/Starting Cell，它是写有内容的最左侧方格，并让其处于起始状态/Starting State，然后将输入的所有内容放在起始方格右侧，并保证纸带其余部分为空。如果磁头抵达状态 $q_h \in Q$，称作停机状态/Halting State，则视作计算结束，并将磁带上从起始方格开始的内容视作输出。我们将图灵机的构型/Configuration 记作

$$
c = t_m t_{m-1} \cdots t_2 t_1 \underline{q_i} s_1 s_2 \cdots s_k
$$

其中 $s_i$ 和 $t_i$ 分别是一直到最右侧/最左侧的非空格子上的内容，$q_i$ 为当前磁头所处的状态，当前磁头指向 $s_1$ 所在的方格。如果磁头进入状态 $q \neq q_h$ 而 $\delta$ 未定义（不移动），则称计算中断，不将其视作停机。

所谓的**图灵计算/Turing Computation** 就指图灵机的一列构型 $c_0, c_1, \cdots, c_n$，它按照如上的叙述由一个图灵程序所描述。

**接受与拒绝**：在判定问题中，图灵机最终需要告诉我们是或者否。实际上图灵机最终会在磁带上留下一个 1 或者 0 代表是或者否，在有些图灵机的定义中，我们会规定写下 1 代表一个 $q_{\text{accept}}$ 状态表示接受，写下 0 代表一个 $q_{\text{reject}}$ 状态表示拒绝，实际上如果我们在进入接受和拒绝状态后再加一个转移函数到停机状态 $q_h$，就和我们的定义相容了。

**非确定性图灵机**：确定性图灵机和非确定性图灵机的唯一区别就在于偏函数。确定性图灵机的值域为 $Q \times (S \cup \{\square\}) \times \{L, R\}$，而非确定性图灵机的值域为其幂集 $\mathcal{P}(Q \times (S \cup \{\square\}) \times \{L, R\})$，也就是说，非确定性图灵机在每一步都有多种选择，而确定性图灵机只有一种选择。如果一条路径使得非确定性图灵机停机，那称非确定性图灵机会停机。在判定性问题中，**只要**有一条路径接受，整个图灵机就接受，只有所有路径都拒绝，整个图灵机才拒绝。换句话说，如果有一种路径可以让非确定型图灵机得到一个解，那么非确定性图灵机就一定会选择这个解。

**定理**：任何一个非确定性图灵机都可以被一个确定性图灵机模拟，也就是**这两类图灵机可以计算的函数是一致的**。

!!! Info "证明"
    为了实现模拟，我们的想法是：因为非确定性图灵机执行时每一步都会产生多种选择，因此所有路径会生成一棵树，确定性图灵机只需要 BFS 搜索这棵树就可以。

    使用一个三条纸带的图灵机模拟：第一条纸带放输入，第二条纸带模拟图灵机读到输入时候的状态和行动，第三条纸带记录 BFS 的进程，提示第二条纸带下一步该模拟哪条路径。只需要证明三条纸带的图灵机和一条纸带的图灵机是等价的，这一点其实是显然的，最简单的方法就是将纸带分成三个部分即可。

在知道这个结论之后，我们还需要意识到确定性图灵机模拟非确定性图灵机的时间复杂度是指数级别的，因为我们需要搜索所有的路径。

**猜想**（Church-Turing 论题）：存在一个现实可行的计算某个函数的方式当且仅当存在一个图灵机计算这个函数。

这个猜想的意义在于，**每一个算法都可以由一个图灵机实现**。其推广模式是现实可行的计算计算系统都可以被图灵机高效地模拟。这样我们发现，我们将两个最重要的问题给抽象化/形式化了：一个是计算问题，一个是计算模型，我们将计算问题转化成了形式语言，将计算模型/算法转化成了图灵机。

于是我们进行最后的形式化：一个形式语言 $L \subset \Sigma^*$ 可以被一个图灵机 $M$ 判定/Decide 当且仅当这个图灵机可以确定任何一个输入字符串 $\omega \in \Sigma^*$ 是否属于形式语言 $L$，其中**确定**的定义为图灵机可以停机并且接受或者拒绝这个字符串。

后面会出现一些形式语言和问题两个几乎一致的东西的混用，我们知道这两个东西的混用本质上是在说一件事就好。

有了计算模型之后，我们可以定义复杂度类了。我们考虑一族函数 $f(n)$，称一个问题是：

- $\mathsf{DTIME}(f(n))$ 的，如果求解规模为 $n$ 的问题的确定性图灵机能在 $f(n)$ 步之内停机；
- $\mathsf{NTIME}(f(n))$ 的，如果求解规模为 $n$ 的问题的非确定性图灵机能在 $f(n)$ 步之内停机。

其中一个形式语言的判定问题指的是输入的长度。有一个加速定理很有意义：

**定理**：如果 $f$ 可以被图灵机 $M$ 在 $T(n)$ 时间内计算，那么对于任意常数 $c \geq 1$，都有一个图灵机 $\overline{M}$ 能够在 $T(n)/c$ 的时间内完成同样的计算。

**证明梗概**：我们只证明 $c = 2$ 的情况，其余情况类似。我们将图灵机的磁头中的有限状态机的两步状态转移合并成一步转移，这样的话我们的字母表也需要同步拓宽，即将原先的字符（包括 $\square$）两两组合。显然我们的计算时间减半。

这个加速定理告诉我们，我们可以将一个图灵机的计算时间缩短任意的常数倍，但是并不能将一个 $O(n^2)$ 复杂度的算法变成 $O(n)$ 复杂度的算法——即便我们可以加速任意常数倍，但是我们不能改变算法复杂度的阶，而加速常数背的算法在这个定理下是毫无意义的。

除此之外，我们可以定义复杂度类了，后面的总结只不过是这个定义的自然语言阐述。

- $\mathsf{P} = \bigcup_{k \geq 1} \mathsf{DTIME}(n^k)$；
- $\mathsf{NP} = \bigcup_{k \geq 1} \mathsf{NTIME}(n^k)$；
- $\mathsf{EXP} = \bigcup_{k \geq 1} \mathsf{DTIME}(2^{nk})$；
- $\mathsf{NEXP} = \bigcup_{k \geq 1} \mathsf{NTIME}(2^{nk})$。

很简单就可以理解这里的定义，$\mathsf{P}$ 就是确定性图灵机能在多项式时间内停机解决的问题，其余类似。另一个平凡的性质是 $\mathsf{NP} \subset \mathsf{EXP}$，因为确定性图灵机模拟非确定性图灵机的开销是指数级别的。下面有一个关于 $\mathsf{NP}$ 类的等价定义。但是首先回忆一个语言是 $\mathsf{NP}$ 的定义：一个非确定性图灵机可以在多项式时间停机并且选择接受或者拒绝这个语言的任何一个字符串。

**定理**：一个语言 $L$ 是 $\mathsf{NP}$ 的当且仅当存在多项式 $p$ 和一个多项式时间的确定性图灵机 $M$，使得对于任意 $x$ 都有

$$
x \in L \Leftrightarrow \exists u \in \{0, 1\}^{p(|x|)}, \text{ s.t. } M(x, u) = 1
$$

其中 $u$ 被称为 $x$ 关于语言 $L$ 的证明/Certificate。所以上式的含义为 $x$ 在 $L$ 中当且仅当存在一个多项式长度的证明使得 $M$ 在多项式时间内接受。其实也就是使用一个确定性图灵机验证了这个解。

**证明梗概**：如果 $L$ 是 $\mathsf{NP}$ 的，那么给出一个非确定性图灵机的选择序列即可作为证明，并且这个序列长度一定是多项式规模的，因为非确定型图灵机在多项式时间内最多完成多项式次分支。而验证只需要一个确定性图灵机在这样的选择序列下执行就可以。如果存在这样的一个证明能被非确定性图灵机接受，那么非确定性图灵机只要不断分支，一定能在多项式时间内分支多项式次，进而凑出这样的一个证明。

最后，仍然需要注意我们引入指数复杂度类不是没有原因的：因为如果 $\mathsf{EXP} \neq \mathsf{NEXP}$，那么 $\mathsf{P} \neq \mathsf{NP}$。

再举一个密码学的例子，我们知道现在的 RSA 密码是基于大合数进行质因数分解的困难性的。所以我们定义语言 


$$
L = \{(m, r) : \exists s < r, s | m\}
$$

这个语言是 $\mathsf{NP}$ 的，这使用确定性图灵机多项式时间内验证就可以很轻松看出来，因为问题的输入是 $m$ 和 $r$，输入的规模就是 $\log_2 m + \log_2 r = \log_2mr$，证明的规模是 $O(\log_2s) = O(\log_2r)$ 的，然后我们就可以在多项式时间内验证这个证明。非确定性图灵机只需要第一次分支到 $s$ 就可以。

还可以通过形式语言的补运算来定义 co-$\mathsf{NP}$ 类：

**定义**：设 $C$ 是一个复杂度类，则 co-$C$ 称为它的补类/Complement Class，其中的语言定义为

$$
\text{co-}\mathsf{C} = \{L : \overline{L} \in \mathsf{C}\}
$$

注意到 co-$\mathsf{C}$ 并不意味着在所有问题意义上的补，而是其中所有语言的补。考虑一下一个语言的补代表什么：还是使用原来哈密顿回路的例子，我们让这个形式语言是所有有哈密顿回路的图，那么这个形式语言的补就是所有没有哈密顿回路的图，这个补类 $\mathcal{L}$ 就是 co-$\mathsf{NP}$。因为我们确实多项式时间内可以确定一个图是有哈密顿回路的（这也就是验证 $\omega \in \overline{\mathcal{L}}$），但是确实难以验证一个图没有哈密顿回路。

**定理**：$\mathsf{P} = \text{co-}\mathsf{P}$。证明显然，只需要将这个图灵机的接受和拒绝、属于和不属于调换就可以。

**定理**：一个语言是 co-$\mathsf{NP}$ 的当且仅当存在多项式 $p$ 和一个多项式时间的确定性图灵机 $M$，使得对于任意 $x$ 都有

$$
x \in L \Leftrightarrow \forall u \in \{0, 1\}^{p(|x|)}, \text{ s.t. } M(x, u) = 0
$$

这里将存在换成了对于任意，这从非确定图灵机的接受和拒绝定义就可以看出来，本定理本质是高中的谓词运算。

实际上 $\mathsf{P} \subset \mathsf{NP} \cap \text{co-}\mathsf{NP}$，进一步的，我们有 $\mathsf{P} = \mathsf{NP} \Rightarrow \mathsf{NP} = \text{co-}\mathsf{NP}$。

### 3. Karp 归约

**定义**：如果一个语言 $A$ 可以被多项式地规约到 $B$，如果存在一个可以在多项式时间内计算的函数 $f$ 使得

$$
x\in A \Leftrightarrow f(x) \in B
$$

记作 $A \leq_p B$。这也就是说，当我们使用解决问题 $B$ 的方法解决问题 $A$ 的时候，可以在多项式时间内完成问题的转化，并且保证问题的解是正确的。显然，规约关系是自反的和传递的。

**定义**：考了复杂度类 $\mathsf{C}$，如果问题 $P$ 满足 $\forall C \in \mathsf{C}, C \leq_p P$，则称 $P$ 是 $\mathsf{C}$-难的（$\mathsf{C}$-hard）；如果同时 $P \in \mathsf{C}$，则称 $P$ 是 $\mathsf{C}$-完全的（$\mathsf{C}$-complete）。

这也就是说，如果问题 $P$ 是 $\mathsf{C}$-难的，那么所有的 $\mathsf{C}$ 问题都可以在多项式时间内规约到问题 $P$，而 $\mathsf{C}$-完全的问题是 $\mathsf{C}$-难的问题中属于 $\mathsf{C}$ 的问题。

### 4. 总结

回忆本讲的核心概念：

- **可判定问题/Decidable Problem**：对于任意输入，确定性图灵机都会停机并且得到正确输出；换句话说，存在一个算法，可以在有限时间内给出正确的输出；
- **不可判定问题/Undecidable Problem**：对于某些输入，确定性图灵机会进入无限循环；换句话说，不存在一个算法，可以在有限时间内给出正确的输出。

典型的不可判定问题是停机问题/Halting Problem。提前说明，**不是所有的可判定问题都是 $\mathsf{NP}$ 的**，比如可以在多项式时间内判定一个图**没有**哈密顿环，但是我们很难在多项式时间内验证解的正确性，因为要验证的话就需要得到哈密顿环的一个解，但是[找到哈密顿环的解是一个 $\mathsf{NP}$ 完全问题](https://en.wikipedia.org/wiki/Hamiltonian_path_problem)。

- **P 问题**：由多项式时间算法可以解决的问题，也就是确定性图灵机可以在多项式时间内解决的问题；
- **NP 问题/Non-deterministic Polytime Problem**：非确定型图灵机在多项式时间内解决的问题，或者确定型图灵机在多项式时间内验证的问题，显然 $\mathsf{P}$ 问题是 $\mathsf{NP}$ 问题的子集。
- **NP 难问题/NP Hard Problem**：可以被任何 $\mathsf{NP}$ 中多项式时间规约到的问题，注意到**不一定是 $\mathsf{NP}$ 问题**；
- **NP 完全问题/NP Complete Problem**：$\mathsf{NP}$ 中的、可以被任何 $\mathsf{NP}$ 问题多项式规约到的问题；

$\mathsf{P}$ 问题显然是可判定问题；一些非 $\mathsf{P}$ 的问题，比如指数时间复杂度的问题也是可判定问题；所有的 $\mathsf{NP}$ 问题也是可判定问题：首先我们可以使用非确定性图灵机解决这些问题，然后可以使用确定性图灵机模拟非确定性图灵机，因此 $\mathsf{NP}$ 问题是可判定问题，值得额外注意的是，使用确定性图灵机模拟非确定性图灵机的过程最差需要指数级别的代价，所以 $\mathsf{NP}$ 问题不仅仅是可判定的，而且还是可以指数时间判定的问题。这其实就蕴含了不是所有的可判定问题都是 $\mathsf{NP}$ 的这件事。不可判定问题就和 $\mathsf{NP}$ 问题无关了。而 co-$\mathsf{NP}$ 问题是 $\mathsf{NP}$ 问题的补问题，对于一个问题的否答案，确定性图灵机可以在多项式时间内验证。这表明我们验证一个相反的解是很容易的。

### 5. 经典例子

一个经典的多项式时间规约的例子是将哈密顿圈问题规约到旅行商问题。哈密顿圈问题是给定一个图，判断其是否有哈密顿圈/经过所有节点的简单环，而旅行商问题是给定一个**加权完全**图和一个整数 $k$，判断其是否有长度不超过 $k$ 的哈密顿圈。这两个问题（HCP 和 TSP）都是经典的 $\mathsf{NP}$ 完全问题。

两个问题的差别几乎是对称的，哈密顿圈问题给定的图不一定是完全图，并且没有加权，而旅行商问题给定的图是完全图并且有加权。我们将待判断 HCP 的图取出来，将现有的边权全部设为 1，然后将其补成完全图，后补充的边权重设为 2。所以如果原图有哈密顿圈，那么新图有长度不超过 $n$ 的哈密顿圈，直接将 $k$ 设为 $n$ 即可。这就完成了规约。

第一个被证明是 $\mathsf{NP}$ 完全问题的问题是 3-SAT 问题，背后其实是 Satisfiability 问题/Circuit-SAT 问题：给定一个布尔表达式，判断其是否有令结果为 1 的解。这个问题是 Cook 在 1971 年证明是 $\mathsf{NP}$ 完全问题的，证明的方法是在非确定图灵机上解决了这个问题。寒假有时间再补充一下这个证明。

!!! Info "坑点"
    **判断**：If a problem can be solved by dynamic programming, it must be solved in polynomial time.

    **答案**：错误，比如最经典的 0-1 背包问题，其动态规划解法的时间复杂度为 $O(nC)$，其中 $n$ 为物品数量，$C$ 为背包容量，因此 0-1 背包问题是**伪多项式时间复杂度**的。回忆一下我们对时间复杂度的确切定义，我们考虑的是输入的**规模**而不是输入的**数值**，而我们输入的背包容量的规模实际上是其在内存中占用的位数 $N = \log_2 C$，因此 0-1 背包问题的时间复杂度实际上是 $O(n2^N)$，这是一个指数时间复杂度的问题。

## 七、Approximation Algorithm

### 1. 0-1 背包问题的 2-近似算法

### 2. 0-1 背包问题的 FPTAS 算法

## 八、Local Search

### 1. 顶点覆盖问题

### 2. Metropolis 算法和模拟退火

### 3. Hopfield 网络

### 4. 最大割问题

