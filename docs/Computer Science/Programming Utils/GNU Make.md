# GNU Make & CMake

!!! Abstract 
    GNU Make 是一个用于自动化编译的工具，它可以根据文件的依赖关系自动执行编译任务。本文将介绍 GNU Make 的基本使用方法。

    为啥要学 Make？

    属于是为了这盘醋包了顿饺子，由于数据结构基础这门课的大作业或多或少需要用到多文件编译，我干脆就希望使用 Make 进行自动化编译，而且在系统课上接触了 Makefile 的编写，所以就有了这篇文章。

## Part 1 别急，先看看 gcc 编译！

gcc 的编译过程可以简要分为四个阶段：**预处理**、**编译**、**汇编**、**链接**。

gcc 编译工具链是以 gcc 编译器为核心的一整套工具，主要包含以下三部分内容：

- gcc-core：亦即 gcc 编译器，用于完成预处理过程和编译过程，将 C 代码转换成汇编代码；
- Binutils：包含了除了 gcc 编译器以外的一系列小工具，比如汇编器 as、连接器 ld、目标文件格式查看器 readelf 等；
- glibc：GNU C Library，是 GNU 组织为了 GNU 系统以及 Linux 系统编写的 C 语言标准库。

### 1.1 预处理/Pre-Processing

预处理阶段的主要任务是处理源文件以 `#` 开头的预处理指令，比如 `#include`、`#define` 等。这里主要是将 `#include` 的一些**头文件**与**宏定义**进行展开，生成一个 `.i` 文件。

预处理过程输入的是 C 的源文件，输出的是一个中间/预加载文件，这个文件还是 C 代码。此阶段使用 gcc 参数 `-E`，同时参数 `-o` 指定了最后输出文件的名字，下面的例子就将 `main.c` **文件经过预处理生成** `main.i` **文件**：

```shell
gcc -E main.c -o main.i
```

### 1.2 编译/Compiling

编译过程使用 gcc 编译器将预处理后的 `.i` 文件通过编译转换为汇编语言，生成一个 `.s` 文件。这是 gcc 编译器完成的工作，在这部分过程之中，gcc 编译器会检查各个源文件的语法，即使我们调用了一个没有定义的函数，也不会报错，

编译过程输入的是一个中间/预加载文件，输出的是一个汇编文件，当然，直接以 C 文件作为输入进行编译也是可以的。此阶段使用 gcc 参数 `-S`，具体例子如下：

```shell
gcc -S main.i -o main.s
gcc -S main.c -o main.s
```

### 1.3 汇编/Assembling

汇编阶段的主要任务是将汇编语言文件经过汇编，生成目标文件 `.o` 文件，每一个源文件都对应一个目标文件。即把汇编语言的代码转换成机器码，这是 as 汇编器完成的工作。

汇编过程输入的是汇编文件，输出 `.o` 后缀的目标文件，gcc 的参数 `-c` 表示只编译源文件但不链接，当然，我们也可以直接输入 C 源文件，就直接包含了前面两个过程。

```shell
gcc -c main.s -o main.o
gcc -c main.c -o main.o
```

Linux下生成的 `.o` 目标文件、`.so` 动态库文件以及下一小节链接阶段生成最终的可执行文件都是 elf 格式的， 可以使用 readelf 工具来查看它们的内容。

从 readelf 的工具输出的信息，可以了解到目标文件包含ELF头、程序头、节等内容，对于 `.o` 目标文件或 `.so` 库文件，编译器在链接阶段利用这些信息把多个文件组织起来，对于可执行文件，系统在运行时根据这些信息加载程序运行。

### 1.4 链接/Linking

最后将每个源文件对应的 `.o` 文件链接起来，就生成了一个可执行程序文件，这是这是链接xx器ld完成的工作。

例如一个工程里包含了 A 和 B 两个代码文件，在链接阶段，链接过程需要把 A 和 B 之间的函数调用关系理顺，也就是说要告诉 A 在哪里能够调用到 `fun` 函数，建立映射关系，所以称之为链接。若链接过程中找不到 `fun` 函数的具体定义，则会链接报错。

链接分为两种：

- 动态链接：gcc 编译时的默认选项。动态是指在应用程序运行时才去加载外部的代码库，不同的程序可以共用代码库。所以动态链接生成的程序比较小，占用较少的内存。
- 静态链接：链接时使用选项 `--static`，它在编译阶段就会把所有用到的库打包到自己的可执行程序中。所以静态链接的优点是具有较好的兼容性，不依赖外部环境，但是生成的程序比较大。

```shell
gcc main.o -o main
gcc main.c -o main --static
```
<!-- 
## Part 2 Makefile

### 2.1 书写规则

Makefile 的规则包括两个部分：一个是**依赖关系/prerequisites**，另一个是**生成目标的方法/command**。在 Makefile 中，规则的顺序是很重要的，Makeflie 中有且仅有一个最终目标，其他目标都是这个目标连带出来的，一般来说，定义在第一条规则的第一个目标就是最终目标，make完成的就是这个目标。

但是我们经常会遇见 `make a.o` 这样的命令，make 后可以跟着一个或多个 target，`a.o` 作为 make 的参数，指定了执行的内容，优先级比 Makefile 里边的定义要高。换句话说，倘若 make 后边有目标，这个目标就是最终目标，make 后边没目标，默认执行 Makefile 的第一个目标。

规则的语法是这样的：

```makefile
targets : prerequisites
    recipe
    ...
```

或者这样的：

```makefile
targets : prerequisites ; command
    recipe
    ...
```

targets 是文件名，可以使用通配符，基本来说，我们的目标基本上是一个文件，可以是一个目标文件，可以是一个可执行文件，还可以是一个标签，是多个文件也是有可能的。

prerequisites 是生成该 target 所依赖的文件或者 target。

recipe 是命令行，可以是**任意**的 shell 命令，如果其不与 `target:prerequisites` 在一行，那么，**必须以 `Tab` 键开头**，如果和 `prerequisites` 在一行，那么可以用分号做为分隔。如果命令太长，我们可以使用反斜杠 `\` 来作为换行符。

以 `Tab` 开头不知道坑了我多少次，可以使用 editorconfig 来设置所有路径下 Makefile 的缩进方式为 `Tab`，这样就不会出现问题了。

规则告诉 make 两件事：一个是文件的依赖关系，target 依赖于 prerequisites 中的文件；另一个时就会如何生成目标文件，生成规则定义在 recipe 中，makefile 最核心的内容是：

<center><b>
prerequisites 中如果有一个以上的文件比 target 文件要新的话，recipe 所定义的命令就会被执行。
</center></b>

对于下面的 Makefile，GNU Make 是这样工作的：

```makefile
main: func.o
    gcc -o main main.c func.o

func.o: func.c func.h
    gcc -c func.c

clean :
    rm main func.o
```

在默认的情况下，如果我们只输入 `make` 命令，那么 

- make 会在当前目录下找名字叫 `Makefile` 或 `makefile` 的文件，如果找到，它会找文件中的第一个目标文件，也就是 `main`，并把这个文件作为最终的目标文件；
- 如果 `main` 文件不存在，或是 `main` 所依赖的后面的 `.o` 文件的文件修改时间要比 `main` 这个文件新，那么，他就会执行后面所定义的命令来生成 `main` 这个文件；
- 如果 `main` 所依赖的 `.o` 文件也不存在，那么 make 会在当前文件中找目标为 `.o` 文件的依赖性，如果找到则再根据那一个规则生成 `.o` 文件；
- 如果依赖的 `.c` 文件和头文件都存在，那么 make 会生成 `.o` 文件，然后再用 `.o` 文件生成 make 的终极任务，也就是可执行文件 `main`，这个寻找依赖关系的过程是递归的；
- 如果在找寻的过程中出现错误，比如最后被依赖的文件找不到，那么 make 就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make 会直接忽略；
- 若是类似 `clean` 这种没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要 make 执行，即命令 `make clean`，以此来清除所有的目标文件，以便重编译；
- 若是 `func.o` 依赖的 `.c` 文件被修改了，那么根据依赖关系，`func.o` 会被重新编译，`func.o` 的文件也是最新的，所以 `func.o` 的文件修改时间要比 `main` 要新，所以 `main` 也会被重新链接.





### 2.2 使用变量

Makefile 中的变量就像是 C 语言的宏一样，代表着一个文本字符串，在执行的时候会自动展开在所使用的地方，不过，我们可以在 Makefile 中改变其值。变量可以使用在目标，规则，依赖目标或者其他部分之中。

在声明变量的时候，我们需要给予其初值，使用的时候需要在变量名前面加上 `$` 符号，最好还用小括号括起来 `()`，变量的名字可以包含字符，数字，下划线，甚至还可以数字开头，但是不能含有 `:`，`#`，`=` 或者空字符。

我们可以使用其他变量来构造变量的值，比如 `foo = $(bar)`，这里的 `bar` 不一定非要是已经定义好的值，我们可以使用后面定义的值，这就很好了嘛，我们可以把变量的真实值退到后面去定义，但是无法避免递归定义，虽然 make 有能力检测这样的定义。

为了避免这个问题，我们使用 `:=` 操作符，对于 `VAR := value`，右边的 `value` 会在定义的时候就被展开。 -->
