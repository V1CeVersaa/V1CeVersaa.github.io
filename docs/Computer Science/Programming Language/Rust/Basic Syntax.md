# Basic Syntax

## 1 变量

### 1.1 命名惯例

| 条目                            | 惯例                               |
|:------------------------------|:---------------------------------|
| 模块 Modules                    | `snake_case`                     |
| 类型 Types                      | `UpperCamelCase`                 |
| 特征 Traits                     | `UpperCamelCase`                 |
| 枚举 Enumerations               | `UpperCamelCase`                 |
| 结构体 Structs                   | `UpperCamelCase`                 |
| 函数 Functions                  | `snake_case`                     |
| 方法 Methods                    | `snake_case`                     |
| 通用构造器 General constructors    | `new` or `with_more_details`     |
| 转换构造器 Conversion constructors | `from_some_other_type`           |
| 宏 Macros                      | `snake_case!`                    |
| 局部变量 Local variables          | `snake_case`                     |
| 静态类型 Statics                  | `SCREAMING_SNAKE_CASE`           |
| 常量 Constants                  | `SCREAMING_SNAKE_CASE`           |
| 类型参数 Type parameters          | `UpperCamelCase`，通常使用一个大写字母: `T` |
| 生命周期 Lifetimes                | 通常使用小写字母: `'a`，`'de`，`'src`      |

### 1.2 变量绑定

使用 `#!rust let` 关键字绑定一个变量，变量绑定默认是不可变的，如果需要可变绑定，使用 `#!rust let mut` 关键字如果后边不会改变的变量被声明为 mutable 的话，编译器会给出警告，如果在存在没有使用的变量的话也会给出警告，在变量名字之前加上单下划线就会忽略未使用的变量。

### 1.3 变量解构

使用 `#!rust let` 关键字还可以进行复杂变量的解构，这也就是从一个相对复杂的变量之中，匹配出这个变量的一部分内容。

### 1.4 所有权

#### 1.4.1 基本规则

- Rust 每一个值都被一个变量所拥有，这个变量被称为这个值的所有者；
- 一个值同时只能被一个变量所拥有；
- 当所有者离开作用域范围的时候，值就会被丢弃。

作用域和别的编程语言没有区别，可以参考块作用域。

#### 1.4.2 转移所有权

对于以拷贝值的方式完成的赋值，没有所有权的转移。

```rust
let x = 5;
let y = x;
```

这段代码当然是通过拷贝值完成赋值的，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过**自动拷贝**的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。当然没有所有权的转移。

```rust
let s1 = String::from("hello");
let s2 = s1;
```



### 1.5 引用

### 1.6 借用

### 1.7 遮蔽


## 2 类型和值

Rust 的类型可以分为两类：基本类型和符合类型。基本类型意味着其是一个最小化原子类型，无法解构为其他类型，有以下几种：

- 数值类型：有符号整数 `i8`, `i16`, `i32`, `i64`, `i128`, `isize`, 无符号整数 `u8`, `u16`, `u32`, `u64`, `u128`, `usize`, 浮点数 `f32`, `f64`；
- 布尔类型：`bool`， 字面量为 `true` 和 `false`；
- 字符类型：`char`，用单引号括起来的 Unicode 字符；
- 单元类型：`()`，只有一个值 `()`，`main` 函数的返回值就是 `()`，这玩意其实就是一个零长度的元组。

复合类型是由其他类型组合而成的，最典型的就是结构体 `struct`，有以下几种：

- 字符串
- 元组
- 结构体
- 枚举
- 数组

### 2.1 数值类型

**序列**是生成连续的数值的

要显式处理溢出，可以使用标注怒对原始数字类型提供的这些方法：

- `wrapping_*`：在所有模式下都按照补码循环溢出规则处理；
- `overflowing_*`：返回该值和一个指示是否发生溢出的布尔值；
- `saturating_*`：限定计算后的结果不超过目标类型的最大值或最小值；
- `checked_*`：如果溢出则返回 `None`。

### 2.2 布尔类型

### 2.3 单元类型

### 2.4 字符类型

### 2.5 字符串 

字符串大抵分为两种，被硬编码到程序代码之中的不可变的字面量 `str`，和用堆动态分配内存的可变的 `String` 类型。在语言级别来说，其实只有一种字符串类型 `str`，并且一般是以引用形式 `&str` 出现的，存储的时候是一个指针和字符串长度。`String` 类型是标准库提供的一个字符串类型，它是一个可变的、可增长的、具有所有权的 UTF-8 编码的字符串类型。 

#### 2.5.1 `String` 和切片

使用 `String::from` 方法将一个字符串字面量转换为 `String` 类型，这里的 `::` 是一种调用操作符，这里表示调用 `String` 模块中的 `from` 方法，由于 `String` 类型的变量 `s` 存储在堆上，因此它是动态的，如果 `s` 是 mut 的，可以通过 `s.push_str("...")` 来追加字面量：

```rust
let mut s = String::from("Hello");
s.push_str(" world!");
println!("{}", s);
```

基于上面的代码，下面介绍切片：切片就是对 `String` 类型之中某一部分的引用，类型就是 `&str`，通过 `[begin..off_the_end]` 指定引用范围，这个范围是左闭右开的（参考 C++ 的尾后迭代器），这和别的编程语言一样。我们可以认为这个语法其实就是数值类型一节中范围的语法，所以 `[begin..=end]` 就生成了一个闭区间的范围。

### 2.6 元组

### 2.7 结构体

### 2.8 枚举

### 2.9 数组

## 3 语句、函数和控制流

### 3.1 语句与表达式

简单说来：

- 带分号的就是一个语句，不带分号的就是一个表达式；
- 能返回一个值的就是一个表达式，表达式会在求值后返回该值，语句会执行一些操作但是不返回值，`#!rust let` 就是一个经典的语句，只负责绑定变量和值，但是不返回值；
- 表达式可以是语句的一部分，`#!rust let a = 1;` 就是一个语句，`1` 其实就是一个表达式；
- 函数调用是表达式，因为返回了一个值，就算不返回值，就会隐式的返回一个 `()`；
- 用花括号括起来的能返回值的代码块是一个表达式，代码块的类型和值就是最后一个表达式的类型和值，如果最后一个表达式是一个分号结尾的语句，那么代码块的类型就是 `()`。

### 3.2 函数

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}
```

上面是典型的函数定义，下面是几个需要注意的点：

- 使用关键词 `fn` 定义一个函数；
- 必须显示指定参数类型，除了返回单元类型 `()`，因为这种情况下编译器会自动推断返回类型，都要显式指定返回类型；
- 中途返回使用 `return` 关键字，带不带分号都可以；
- 以语句为最后一行代码的函数，返回值是 `()`；
- 永远不返回的函数类型为 `!`，一般用于一定会抛出 panic 的函数，或者无限循环的函数。
- 由于函数也返回值，所以函数调用也是一个表达式，可以用在赋值语句的右边。

### 3.3 控制流

### 3.4 简单的宏

宏在编译过程中会扩展为 Rust 代码，并且可以接受可变数量的参数。它们以 `!` 结尾来进行区分。Rust 标准库包含各种有用的宏。

- `println!(format, ..)` 在标准输出中打印一行字符串；
- `format!(format, ..)` 的用法与 `println!` 类似，但并不打印，它以字符串形式返回结果；
- `dbg!(expression)` 会记录表达式的值并返回该值；
- `todo!()` 用于标记尚未实现的代码段。如果执行该代码段，则会触发 panic；
- `unreachable!()` 用于标记无法访问的代码段。如果执行该代码段，则会触发 panic；
- `assert_eq!(left, right)` 用于断言两个值是否相等；

