# Basic Syntax

## Initialization

初始化是指在创建对象（为特定类型的对象申请存储空间）的同时赋初始值。C++ 的初始化方式与规则五花八门，大概包括以下几种：直接初始化、拷贝初始化、列表初始化、默认初始化、值初始化、类内初始值、构造函数初始值列表。

一般有着四类初始化方式，现代 C++ 的内置类型和类类型都支持这四种初始化方式：

- 等号：`int a = 1;` 或者 `std::string s = "hello";`
- 等号加花括号：`int a = {1};` 或者 `std::string s = {"hello"};`
- 花括号：`int a{1};` 或者 `std::string s{"hello"};`
- 圆括号：`int a(1);` 或者 `std::string s("hello");`

**默认初始化/Default Initialization**：当对象未被显示地赋予初值时执行的初始化行为。

- 类类型：由类的**默认无参构造函数**决定，如果没有默认无参构造函数，则该类不支持默认初始化。
- 内置类型（指针、`int`、`double`、`float`、`bool`、`char` 等）及其数组：
    - 全局（包括定义在任何函数之外、命名空间之内的）变量或局部静态变量：初始化为 0（这种情况也叫值初始化）；
    - 局部非静态变量或类成员：未定义（未初始化）。

```cpp
int i;                    // 默认初始化：未定义
std::string s;            // 默认初始化：调用默认构造函数，得到空字符串
MyClass* p = new MyClass; // 默认初始化：全看构造函数
double* pd = new double   // 默认初始化：0.0
```

**值初始化/Value Initialization**：默认初始化的特殊情况，此时内置类型会被初始化为 0。基本场景：

- STL 容器只指定元素数量，而不指定初值时，就会执行值初始化，如 `vector<int> vec(10);`：10 个 `int`，初始化为 `0`；
- 全局（包括定义在任何函数之外、命名空间之内的）变量或局部静态变量：初始化为 0；
- `new` 类型，后面带括号，如：new int()， new string{}；
- 初始值列表为空 `{}`，如 `double d{};`、`int *p{};`。

对于类类型，其实不需要区分默认初始化和值初始化，因为类类型的初始化只决定于构造函数，与对象在函数内/外、全局/局部/类成员、静态/非静态、默认初始化/值初始化无关。

## Iterator

## Functions

### 1 Basics

一个典型的函数包括：返回类型、函数名字、形参列表与函数体，使用调用运算符来执行函数，调用运算符的形式是一对圆括号，运算符作用于一个表达式，这个表达式是函数或者指向函数的指针，调用表达式的类型就是函数的返回类型。

函数的调用其实完成了两项工作：一个是使用实参初始化函数对应的形参，另一个是将控制权从主调函数转移到被调函数。而返回语句也完成两项工作：一个是返回 `return` 语句中的值，另一个是将控制权从被调函数转移到主调函数。

当形参列表为空的时候，可以直接书写一个空的形参列表，但是与 C 语言兼容的形式是使用 `void` 关键字。

在 C++ 中，名字有**作用域**，对象有**生命周期/Lifetime**，作用域是程序文本的一部分，名字在作用域中可见，对象的生命周期是程序执行过程中对象存在的一段时间。

函数体是一个语句块，块构成一个新的作用域。函数的形式参数和函数体内部定义的变量统称为**局部变量**，局部变量只有在函数的作用域内可见，并且会隐藏在外层作用域中同名的其他声明。

