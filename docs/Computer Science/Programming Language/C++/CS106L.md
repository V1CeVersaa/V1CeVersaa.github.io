# CS106L ç¬”è®°

!!! Info "Table of Contents"

    - [x] [Lecture 8ï¼šæ¨¡ç‰ˆç±»](#lecture-8)
    - [x] [Lecture 9ï¼šæ¨¡ç‰ˆå‡½æ•°](#lecture-9)
    - [x] [Lecture 10ï¼šå‡½æ•°ä¸ Lambda è¡¨è¾¾å¼](#lecture-10-lambda)
    - [x] [Lecture 11ï¼šè¿ç®—ç¬¦é‡è½½](#lecture-11)
    - [x] [Lecture 12ï¼šç‰¹æ®Šæˆå‘˜å‡½æ•°](#lecture-12)
    - [x] [Lecture 13ï¼šç§»åŠ¨è¯­ä¹‰](#lecture-13)
    - [x] [Lecture 14ï¼šOptional å’Œç±»å‹å®‰å…¨](#lecture-14optional)
    - [x] [Lecture 15ï¼šRAII å’Œæ™ºèƒ½æŒ‡é’ˆ](#lecture-15raii)
    - [ ] [Appendix](#appendix)

## Lecture 8ï¼šæ¨¡ç‰ˆç±»

!!! Info

    æ³¨æ„**æ¨¡ç‰ˆç±»**å’Œ**ç±»æ¨¡ç‰ˆ**çš„åŒºåˆ«ï¼š

    - **ç±»æ¨¡ç‰ˆ/Class Template**ï¼šæ˜¯ä¸€ä¸ªæ¨¡ç‰ˆï¼Œç”¨äºç”Ÿæˆç±»çš„å®šä¹‰ï¼Œç¼–è¯‘å™¨ä¼šä½¿ç”¨å®ƒæ¥å®ä¾‹åŒ–å„ç§å…·ä½“çš„ç±»ã€‚
    - **æ¨¡ç‰ˆç±»/Template Class**ï¼šæ˜¯ä¸€ä¸ªç±»æ¨¡ç‰ˆå®ä¾‹åŒ–åçš„å…·ä½“ç±»ï¼Œå½“ä½¿ç”¨ç±»æ¨¡ç‰ˆå®šä¹‰å¯¹è±¡æ—¶ï¼Œéœ€è¦æŒ‡å®šå®é™…çš„ç±»å‹å‚æ•°ï¼Œä»è€Œç”Ÿæˆæ¨¡ç‰ˆç±»ã€‚

!!! Note "ã€Œ`this` æŒ‡é’ˆã€"

    å¯¹äºå¦‚ä¸‹å®šä¹‰çš„ç±» `Point`ï¼š

    ```cpp
    class Point {
       public:
        Point() = default;
        Point(int x, int y) : x(x), y(y) {}
        int getX() const { return x; }
        int getY() const { return y; }
        void setX(int x) { this->x = x; }
        void setY(int y) { this->y = y; }
    
       private:
        int x = 0;
        int y = 0;
    };
    ```

    `this` æ˜¯ä¸€ä¸ªæŒ‡å‘å½“å‰ç±»å®ä¾‹çš„æŒ‡é’ˆï¼Œé€šè¿‡ä¸Šä¸ªä¾‹å­ä¸­çš„ `Point::setX` å‡½æ•°ï¼Œå¯ä»¥çœ‹åˆ° `this` æŒ‡é’ˆçš„ä½œç”¨ã€‚

é¦–å…ˆå®šä¹‰ä¸€ä¸ªç±»æ¨¡ç‰ˆ `Vector`ï¼š

```cpp
template <typename T>
class Vector {
   public:
    T& at(size_t index);
    void push_back(const T& elem);

   private:
    T* elems;
};
```

- æ¨¡ç‰ˆå£°æ˜ï¼š`Vector` æ˜¯ä¸€ä¸ªæ¨¡ç‰ˆï¼Œæ¥å—ç±»å‹å‚æ•° `T`ï¼›
- æ¨¡ç‰ˆå®ä¾‹åŒ–ï¼šå½“ä½¿ç”¨å¯¹åº”çš„å®ä¾‹çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®æŒ‡å®šçš„å…·ä½“ç±»å‹ç”Ÿæˆç›¸åº”çš„ä»£ç ã€‚

    ```cpp
    Vector<int> intVector;
    Vector<std::string> stringVector;
    ```

- `Vector<int>` å’Œ `Vector<std::string>` æ˜¯ `Vector` çš„ä¸¤ä¸ªå®ä¾‹ï¼Œä½†æ˜¯è¿™ä¸¤ä¸ªå®ä¾‹æ˜¯å®Œå…¨ä¸åŒçš„ã€‚
    
    > These two instantiations (of the same template) are completely different (runtime and compile-time) types.

- é™¤äº† `typename`ï¼Œæ¨¡ç‰ˆå‚æ•°è¿˜å¯ä»¥æ˜¯åˆ«çš„ç±»å‹ï¼Œå¹¶ä¸”åœ¨æ¨¡ç‰ˆä¸­ï¼Œ`typename` å’Œ `class` æ˜¯ç­‰ä»·çš„ã€‚

    ```cpp
    template <typename T, std::size_t N>
    struct std::array;

    std::array<int, 5> arr; // An array of exactly 5 integers

    template <class T, std::size_t N>
    struct std::array;      // Equivalent to the above
    ```

- å£°æ˜æˆå‘˜å‡½æ•°çš„æ—¶å€™éœ€è¦æ³¨æ„ï¼Œå¯¹äºä¸Šé¢ç±»æ¨¡ç‰ˆ `Vector` è€Œè¨€ï¼Œ`Vector` ä¸æ˜¯ä¸€ä¸ªç±»å‹ï¼Œä½†æ˜¯ `Vector<T>` æ˜¯ä¸€ä¸ªç±»å‹ã€‚

    ```cpp
    template <typename T>
    T& Vector<T>::at(size_t index) {
        return elems[index];
    }
    ```

- æ³¨æ„ç±»æ¨¡ç‰ˆçš„å®ç°ï¼šåœ¨ `.h` æ–‡ä»¶ä¸­å®šä¹‰æ¥å£ï¼Œåœ¨ `.cpp` æ–‡ä»¶ä¸­å®ç°å¯¹åº”å‡½æ•°ï¼Œåœ¨ `.h` æ–‡ä»¶çš„ç»“å°¾ `#include` å¯¹åº”çš„ `.cpp` æ–‡ä»¶ã€‚
- å…³äº `const`ï¼š

    ```cpp
    template <typename T>
    class Vector {
       public:
        size_t size();
        T& at(size_t index);
    };

    void printVec (const Vector<int>& vec) {
        for (size_t i = 0; i < vec.size(); ++i) {
            std::cout << vec.at(i) << std::endl;
        }
    }
    ```

    æˆ‘ä»¬æ³¨æ„åˆ°ç¬¬ 8 è¡Œçš„ `const`ï¼Œè¿™ä¸ª `const` è¡¨ç¤ºä¼ å…¥çš„ `vec` æ˜¯ä¸€ä¸ªå¸¸é‡å¼•ç”¨ï¼Œæˆ‘ä»¬æ‰¿è¯ºä¸ä¿®æ”¹ `vec`ï¼Œä½†æ˜¯å¯¹åº”çš„ `size` å’Œ `at` å‡½æ•°å¹¶æ²¡æœ‰å£°æ˜ä¸º `const`ï¼Œç¼–è¯‘å™¨ä¸èƒ½ç¡®å®šè¿™ä¸¤ä¸ªå‡½æ•°æ˜¯å¦ä¼šä¿®æ”¹ `vec`ï¼Œæ‰€ä»¥ä¼šæŠ¥é”™ã€‚ä¿®æ”¹æˆä¸‹é¢çš„æ ·å­å°±å¥½äº†ã€‚

    ```cpp
    size_t size() const;
    T& at(size_t index) const;      // æ›´åº”è¯¥æ˜¯ const T& at(size_t index) const;
    ```

    å¯¹äº `const` æˆå‘˜å‡½æ•°ï¼Œä¼ å…¥çš„ `this` æŒ‡é’ˆæ˜¯ä¸€ä¸ªæŒ‡å‘å¸¸é‡çš„æŒ‡é’ˆï¼Œåœ¨ä¸Šé¢å°±æ˜¯ `const Vector<int>* this`ï¼Œè¿™æ ·å°±ä¸èƒ½åœ¨æˆå‘˜å‡½æ•°å†…ä¿®æ”¹æˆå‘˜å˜é‡äº†ã€‚

    **å¯¹äºå®šä¹‰æˆ `const` çš„å¯¹è±¡ï¼Œæˆ‘ä»¬åªèƒ½ä½¿ç”¨ `const` æ¥å£**ï¼Œå…¶ä¸­ `const` æ¥å£æ˜¯æŒ‡é‚£äº›è¢«å®šä¹‰æˆ `const` çš„æˆå‘˜å‡½æ•°ã€‚

    åŸºäº `const`ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°é‡è½½ã€‚è¿™æ ·ï¼Œæ¥å— `const` å‚æ•°çš„å‡½æ•°å°±ä¸èƒ½éšä¾¿ä¿®æ”¹å¯¹åº”çš„ `const` å¯¹è±¡ï¼Œè€Œæ¥å—é `const` å‚æ•°çš„å‡½æ•°å¯ä»¥ä¿®æ”¹å¯¹åº”çš„å¯¹è±¡ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„å‡½æ•°ã€‚

    ```cpp
    const T& at(size_t index) const;
    T& at(size_t index);
    ```

- å…³äº `const_cast`ï¼šä½¿ç”¨ä¸º `const_cast<target_type>(expr)`ï¼Œcast away the const-ness of a variableã€‚

    ```cpp
    template <typename T>
    T& Vector<T>::findElement(const T& value) {
        for (size_t i = 0; i < size; ++i) {
            if (elems[i] == value) return elems[i];
        }
        throw std::runtime_error("Element not found");
    }

    template <typename T>
    const T& Vector<T>::findElement(const T& value) const {
        return const_cast<Vector<T>&>(*this).findElement(value);
    }
    ```

    è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ `const_cast` æ¥å°† `const` çš„ `*this` è½¬æ¢ä¸ºé `const` é¥®ç”¨ `const Vector<T>&`ï¼Œç„¶åè°ƒç”¨é `const` ç‰ˆæœ¬çš„ `findElement` å‡½æ•°ã€‚ä½†æ˜¯æ•´ä½“è¿˜æ˜¯ `const` å‡½æ•°ã€‚

- å…³äº `mutable`ï¼š`mutable` ä¿®é¥°çš„æˆå‘˜å˜é‡å¯ä»¥åœ¨ `const` å‡½æ•°ä¸­ä¿®æ”¹ã€‚

## Lecture 9ï¼šæ¨¡ç‰ˆå‡½æ•°

### 9.1 ç®€å•çš„ä¾‹å­

å‡½æ•°æ¨¡ç‰ˆæ˜¯ä¸€ç§æ³›å‹å‡½æ•°/Generic Functionã€‚

```cpp
template <typename T>
T min (const T &a, const T &b) {
    return a < b ? a : b;
}

template <typename T, typename U>
auto min(const T &a, const U &b) {
    return a < b ? a : b;
}
```

å®ä¾‹åŒ–æ–¹æ³•å¯¹åº”æœ‰ä¸¤ç§ï¼šå¯ä»¥ç›´æ¥æŒ‡å®šç±»å‹ï¼Œä¹Ÿå¯ä»¥è®©ç¼–è¯‘å™¨è‡ªè¡Œæ¨æ–­ï¼Œä½†æ˜¯æ¨æ–­çš„ç»“æœä¸ä¸€å®šå¦‚ä½¿ç”¨è€…æœ¬æ„ï¼ˆæ¯”å¦‚ä¼šæŠŠå­—ç¬¦ä¸²å­—é¢é‡æ¨æ–­æˆ `const char*`ï¼‰ï¼š

```cpp
min<int>(3, 4);                     // æ˜¾å¼å®ä¾‹åŒ–ï¼šç¼–è¯‘å™¨å¸®æˆ‘ä»¬ç”Ÿæˆå¯¹åº”ä»£ç 
min(3.14, 2.71);                    // éšå¼å®ä¾‹åŒ–ï¼šç¼–è¯‘å™¨è‡ªè¡Œæ¨æ–­æ•°æ®ç±»å‹
min("hello", "world");              // éšå¼å®ä¾‹åŒ–ï¼šç¼–è¯‘å™¨è‡ªè¡Œæ¨æ–­æ•°æ®ç±»å‹
min<const char*>("hello", "world"); // æ˜¾å¼å®ä¾‹åŒ–ï¼šä¸Šä¸€è¡Œå¯¹åº”çš„å…¶å®æ˜¯è¿™ä¸ª
```

è¿˜å¯ä»¥å†™æ›´å¤æ‚çš„æ¨¡ç‰ˆï¼š

```cpp
template <class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T &value);
```

### 9.2 Concepts

æƒ³æ³•ï¼šè¦æ±‚æ¨¡ç‰ˆå‡½æ•°çš„ç±»å‹å‚æ•°éœ€è¦æœ‰æŸç§ç‰¹å®šçš„å±æ€§ï¼Œæ¯”å¦‚ `min` éœ€è¦ç±»å‹å‚æ•°æ”¯æŒ `<` è¿ç®—ç¬¦ï¼Œ`find` éœ€è¦ç±»å‹å‚æ•° `InputIt` æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ã€‚

```cpp
template <typename T>
concept Comparable = requires(const T &a, const T &b) {
    { a < b } -> std::convertible_to<bool>;
};
```

å…¶ä¸­ï¼š

- `#!cpp concept`ï¼šä»£è¡¨é™åˆ¶çš„ä¸€ä¸ªæœ‰åé›†åˆï¼ˆa named set of constraintsï¼‰ï¼›
- `#!cpp requires(const T &a, const T &b)`ï¼šæŒ‡å®šç±»å‹ `T` å¿…é¡»æ»¡è¶³çš„æ¡ä»¶ï¼Œè¿™é‡Œæˆ‘ä»¬è¦æ±‚ç±»å‹ `T` å¿…é¡»èƒ½å¤Ÿæ¥å—ä¸¤ä¸ªå¸¸é‡å¼•ç”¨å‚æ•°ï¼Œå¹¶ä¸”æ»¡è¶³ä¸‹é¢æ¡ä»¶ï¼›
- `#!cpp { a < b } -> std::convertible_to<bool>`ï¼šè¿™é‡Œæˆ‘ä»¬è¦æ±‚èŠ±æ‹¬å· `{}` å†…çš„ `a < b` å¿…é¡»ä¸å­˜åœ¨ç¼–è¯‘é”™è¯¯ï¼Œå¹¶ä¸”è¿”å›å€¼å¿…é¡»å¯ä»¥è½¬æ¢ä¸º `bool` ç±»å‹ã€‚æ³¨æ„åˆ° `std::convertible_to` ä¹Ÿæ˜¯ä¸€ä¸ª conceptã€‚

ä½¿ç”¨ conceptï¼Œæˆ‘ä»¬å¯ä»¥ä¿®æ”¹æˆ‘ä»¬çš„ä»£ç ï¼Œä¸‹é¢ä¸¤ç§å†™æ³•éƒ½æ˜¯å¯¹çš„ï¼š

```cpp
template <typename T> requires Comparable<T>
T min(const T &a, const T &b);

template <Comparable T>
T min(const T &a, const T &b);

template <std::input_iterator InputIt, class T>
InputIt find(InputIt first, InputIt last, const T &value);
```

### 9.3 å˜å‚æ¨¡ç‰ˆ

æƒ³æ³•ï¼šæˆ‘ä»¬å¸Œæœ›åˆ›å»ºå¯ä»¥æ¥å—ä»»æ„æ•°é‡å‚æ•°çš„æ¨¡ç‰ˆå‡½æ•°ï¼Œä½†æ˜¯å‡½æ•°é‡è½½çš„å®ç°å¤ªè¿‡ç¬¨æ‹™ï¼Œè€ƒè™‘ç”¨é€’å½’çš„å½¢å¼ç®€åŒ–å®ç°ã€‚

```cpp
template <Comparable T>
T min(const T &v) { return v; }

template <Comparable T, Comparable... Args>
T min(const T &v, const Args &...args) {
    auto m = min(args...);
    return v < m ? v : m;
}
```

æ³¨æ„ï¼š

- åªæœ‰ä¸€ä¸ªå‚æ•°çš„ç‰ˆæœ¬æ˜¯ Base Case Functionï¼›
- `Args` æ˜¯ä¸€ä¸ªå‚æ•°åŒ…ï¼Œå¯¹åº”ç€ 0 ä¸ªæˆ–è€…æ›´å¤šç§ç±»å‹ï¼Œ`args` æ˜¯å®é™…çš„å‚æ•°å€¼ï¼›
- åœ¨ `#!cpp auto m = min(args...);` è¿™ä¸€è¡Œæ‰§è¡Œäº†åŒ…å±•å¼€ï¼Œå°† `args...` å±•å¼€æˆäº†çœŸæ­£çš„å‚æ•°ã€‚

åœ¨ `#!cpp min<int, int, int, int>(2, 7, 5, 1)` çš„æœ€åˆè°ƒç”¨ä¸­ï¼š`#!cpp T = int`ï¼Œ`#!cpp Args = [int, int, int]`ã€‚

ç¼–è¯‘å™¨é€šè¿‡é€’å½’ç”Ÿæˆä»»æ„æ•°é‡çš„é‡è½½ï¼Œè¿™ä½¿å¾—æˆ‘ä»¬å¯ä»¥æ”¯æŒä»»æ„æ•°é‡çš„å‡½æ•°å‚æ•°ï¼›å®ä¾‹åŒ–å‘ç”Ÿåœ¨ç¼–è¯‘æ—¶ã€‚

???- Info "Example for `sum()`"

    ```cpp
    #include <string>
    #include <string_view>
    #include <type_traits>

    inline double convertStringToNumber(const std::string_view& str) { return std::stod(std::string(str)); }

    template <typename T>
    typename std::enable_if<std::is_arithmetic<T>::value, double>::type convertToNumber(T value) {
        return static_cast<double>(value);
    }

    template <typename T>
    typename std::enable_if<std::is_convertible<T, std::string_view>::value, double>::type convertToNumber(const T& value) {
        return convertStringToNumber(value);
    }

    inline double sum() { return 0.0; }

    template <typename T, typename... Args>
    double sum(T first, Args... rest) {
        return convertToNumber(first) + sum(rest...);
    }
    ```

### 9.4 æ¨¡ç‰ˆå…ƒç¼–ç¨‹

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨å‡½æ•°æ¨¡æ¿çš„ç‰¹æ€§æ¥è¿›è¡Œä¸€äº›ç¼–è¯‘æœŸçš„è®¡ç®—ï¼Œè¿™è¢«ç§°ä¸ºæ¨¡æ¿å…ƒç¼–ç¨‹/Templates Metaprogrammingã€‚

```cpp
template <>
struct Factorial<0> {
    enum { value = 1 };     // enum: One way to store a compile-time constant
};

template <std::size_t N>
struct Factorial {
    enum { value = N * Factorial<N - 1>::value };
};

std::cout << Factorial<5>::value << std::endl;  // 120
```

TMP æ˜¯å›¾çµå®Œå¤‡çš„ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ç¼–è¯‘æœŸæ‰§è¡Œä»»ä½•ä»£ç ï¼ˆä½†æ˜¯å†™å‡ºæ¥ä¸€èˆ¬å¾ˆä¸‘ï¼‰ã€‚`constexpr` å’Œ `consteval` ä¸ºæˆ‘ä»¬æä¾›äº† TMP çš„ä¸€ä¸ªæ›¿ä»£å“ï¼š

```cpp
constexpr std::size_t factorial(std::size_t n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}

consteval std::size_t factorial(std::size_t n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}
```

- `#!cpp constexpr`ï¼šå…è®¸ç¼–è¯‘æ—¶æ±‚å€¼ï¼Œä½†æ˜¯å¦‚æœæ¡ä»¶ä¸æ»¡è¶³ï¼Œå¯ä»¥é€€åŒ–ä¸ºæ™®é€šå‡½æ•°ï¼›
    - è¦æ±‚ï¼šå‚æ•°å’Œè¿”å›å€¼å¿…é¡»æ˜¯å­—é¢å€¼ç±»å‹ï¼Œä¸èƒ½æœ‰å‰¯ä½œç”¨ï¼Œåªèƒ½è°ƒç”¨ `constexpr` å‡½æ•°ã€‚
    - æ€§è´¨ï¼šå¯¹åº”å‡½æ•°æ˜¯çº¯å‡½æ•°ï¼Œè¿”å›å€¼éšå« `const` å±æ€§ã€‚
- `#!cpp consteval`ï¼šå¼ºåˆ¶ç¼–è¯‘æ—¶æ±‚å€¼ï¼Œå¦‚æœä¸èƒ½åœ¨ç¼–è¯‘æ—¶æ±‚å€¼ï¼Œåˆ™ç¼–è¯‘å¤±è´¥ã€‚
    - è¦æ±‚ï¼šä¸èƒ½æœ‰é™æ€å˜é‡ï¼Œä¸èƒ½æœ‰å‰¯ä½œç”¨ï¼Œä¸èƒ½åœ¨è¿è¡Œæ—¶ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ã€‚

## Lecture 10ï¼šå‡½æ•°ä¸ Lambda è¡¨è¾¾å¼

### 10.1 è°“è¯å‡½æ•°

!!! Info "**ã€Œè°“è¯å‡½æ•°ã€**"
    è°“è¯å‡½æ•°/Predicate æ˜¯ä¸€ä¸ªè¿”å› `bool` ç±»å‹çš„å‡½æ•°ï¼Œé€šå¸¸ç”¨äº STL ä¸­ã€‚

    ```cpp
    bool isEven(int x) {
        return x % 2 == 0;
    }
    
    bool isLessThan (int x, int y) {
        return x < y;
    }
    ```

æƒ³æ³•ï¼šé€šè¿‡ä¼ å…¥è°“è¯å‡½æ•°ï¼Œå¯ä»¥è¿›ä¸€æ­¥ç®€åŒ–ä¸Šä¸€èŠ‚ä¸­çš„ `find` å‡½æ•°ã€‚æ¨å¹¿å¼€æ¥ï¼Œå®šä¹‰åºå…³ç³»åï¼Œç¨‹åºä¼šæ›´åŠ ç®€å•ã€‚

```cpp
template <typename It, typename Pred>
It find_if(It first, It last, Pred pred) {
    for (It it = first; it != last; ++it) {
        if (pred(*it)) return it;
    }
    return last;
}

bool isVowel(char c) {
    c = ::tolower(c);
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'; 
}

std::string s = "Hello, World!";
std::string::iterator it = find_if(s.begin(), s.end(), isVowel);
```

å°†å‡½æ•°ä½œä¸ºå‚æ•°ä¼ é€’å…è®¸æˆ‘ä»¬å°†ç®—æ³•ä¸ç”¨æˆ·å®šä¹‰çš„è¡Œä¸ºè¿›è¡Œæ³›åŒ–ã€‚
> Passing functions allows us to **generalize** an algorithm with **user-defined behaviour**.

äº‹å®ä¸Šï¼Œ`Pred` æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œå¯¹ä¸Šè¿°å¼å­æ¥è¯´ï¼Œ`Pred` çš„ç±»å‹æ˜¯ `#!cpp bool(*)(char)`ã€‚

ä½†æ˜¯ï¼Œå•çº¯ä¼ é€’å‡½æ•°æŒ‡é’ˆä½œä¸ºå‚æ•°æ˜¯ä¸ªå¾ˆå¥½çš„æƒ³æ³•ï¼Œç„¶è€Œå‡½æ•°æŒ‡é’ˆçš„æ³›åŒ–èƒ½åŠ›æœ‰é™ï¼ˆä¿®æ”¹ä¸€ä¸‹ä¸Šé¢é‚£æ®µä»£ç ä½¿å¾— `isVowel` å¯ä»¥æ¥å—ä¸¤ä¸ªå‚æ•°å°±çŸ¥é“äº†ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¼•å…¥äº† Lambda è¡¨è¾¾å¼ã€‚

### 10.2 Lambda è¡¨è¾¾å¼

Lambda å‡½æ•°æ˜¯ä»æ‰€åœ¨çš„ä½œç”¨åŸŸæ•è·çŠ¶æ€çš„å‡½æ•°ã€‚
> Lambda functions are functions that capture state from an enclosing scope.

```cpp
int n;
std::cin >> n;

auto lessThanN = [n](int x) { return x < n; };
```

Lambda è¡¨è¾¾å¼çš„å®Œæ•´å£°æ˜å¦‚ä¸‹ï¼š`#!cpp [capture-values](arguments) mutable exception-> return type { function-body };`ï¼š

- æ–¹æ‹¬å· `[]` å†…çš„æ˜¯æ•è·åˆ—è¡¨ï¼Œå¯ä»¥è®©å‡½æ•°ä½“å†…ä½¿ç”¨å¤–ä¾§çš„å˜é‡ï¼›
- æ‹¬å· `()` å†…çš„æ˜¯å‚æ•°åˆ—è¡¨ï¼Œå’Œæ­£å¸¸çš„å‡½æ•°æ— å¼‚ï¼›
- `mutable` å…³é”®å­—è¡¨ç¤º Lambda å‡½æ•°å¯ä»¥ä¿®æ”¹æ•è·çš„å˜é‡ï¼›
- èŠ±æ‹¬å· `{}` å†…çš„æ˜¯å‡½æ•°ä½“ï¼Œä½†æ˜¯åªæœ‰å‚æ•°åˆ—è¡¨å’Œæ•è·çš„å˜é‡å¯ä»¥è¢«è®¿é—®ã€‚

æ•è·æ–¹å¼å¦‚ä¸‹ï¼š

- `[x]`ï¼šæŒ‰å€¼æ•è· xï¼ˆåˆ›å»ºå‰¯æœ¬ï¼‰ï¼›
- `[x&]`ï¼šæŒ‰å¼•ç”¨æ•è· xï¼›
- `[x, y]`ï¼šæŒ‰å€¼æ•è· x å’Œ yï¼›
- `[&]`ï¼šæŒ‰å¼•ç”¨æ•è·æ‰€æœ‰å˜é‡ï¼›
- `[&, x]`ï¼šé™¤äº† x æŒ‰å€¼æ•è·å¤–ï¼Œå…¶ä»–éƒ½æŒ‰å¼•ç”¨æ•è·ï¼›
- `[=]`ï¼šæŒ‰å€¼æ•è·æ‰€æœ‰å˜é‡ã€‚
- `[]`ï¼šä¸æ•è·ä»»ä½•å˜é‡ã€‚

ä¸€ä¸ªå‡½å­/Functor æ˜¯é‡è½½äº† `operator()` çš„ç±»ï¼ŒLambda è¡¨è¾¾å¼æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªåŒ¿åçš„å‡½å­ã€‚
> Definition: A functor is any object that defines an operator()

```cpp
template <typename T>
struct std::greater {
    bool operator()(const T& x, const T& y) const {
        return x > y;
    }
};

std::greater<int> greaterThan;
greaterThan(3, 5);              // false
```

æ—¢ç„¶å‡½å­æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒå½“ç„¶å¯ä»¥æœ‰çŠ¶æ€ï¼š

```cpp
struct my_functor {
    bool opearator()(int a) const {
        return a * value;
    }

    int value;
}

my_functor f;
f.value = 3;
f(5);       // 15
```

æˆ‘ä»¬é€šè¿‡ç”Ÿæˆå‡½å­æ¥ç”Ÿæˆ Lambda è¡¨è¾¾å¼ï¼š

```cpp
int n = 10;
auto lessThanN = [n](int x) { return x < n; }
find_if(begin, end, lessThanN);
```

å…¶ä¸­çš„ Lambda è¡¨è¾¾å¼å°±ç­‰ä»·äºï¼š

```cpp
class __lambda_6_18 {
   public:
    bool operator()(int x) const { return x < n; }
    __lambda_6_18(int &n) : n{_n} {}
   private: 
    int n;
};

int n = 10;
auto lessThanN = __lambda_6_18(n);
find_if(begin, end, lessThanN);
```

å¦å¤–ï¼Œ`#!cpp std::function` æ˜¯æ‰€æœ‰å‡½æ•°/Lambda è¡¨è¾¾å¼çš„ç»Ÿä¸€ç±»å‹ï¼Œæ‰€æœ‰å‡½æ•°æŒ‡é’ˆ/å‡½å­/Lambda è¡¨è¾¾å¼éƒ½å¯ä»¥è½¬åŒ–æˆè¿™ç§ç±»å‹ï¼Œä½†æ˜¯è¿è¡Œç¨å¾®æ…¢ä¸€ç‚¹ã€‚

### 10.3 Range å’Œ View

Range æ˜¯å®šä¹‰äº† `begin` å’Œ `end` çš„ä»»ä½•ä¸œè¥¿ã€‚
> Definition: A range is anything with a begin and end.

åƒ `std::vector`ã€`std::string`ã€`std::set`ã€`std::map` éƒ½æ˜¯ Rangeã€‚ 

Range æä¾›äº†å¾ˆå¤šæœ‰æ•ˆçš„å‡½æ•°ï¼Œæ¯”å¦‚ `std::ranges::find`ï¼š

```cpp
std::vector<char> v = {'a', 'b', 'c', 'd', 'e'};
auto it_ = std::find(v.begin(), v.end(). 'c');
auto it  = std::ranges::find(v, 'c');
auto _it = std::ranges::find(v.begin() + 1, v.end() -  1, 'c');
```

View/è§†å›¾æä¾›ä¸€ç§ç»„åˆç®—æ³•çš„æ–¹å¼ï¼ŒView æ˜¯ä¸€ç§æƒ°æ€§åœ°é€‚é…å¦ä¸€ä¸ª Range çš„ Rangeã€‚
> Views: a way to compose algorithms.  
> Definition: A view is a range that lazily adapts another range.

```cpp
std::vector<char> v = {'a', 'b', 'c', 'd', 'e'};
std::vector<char> f, t;

std::copy_if(v.begin(), v.end(), std::back_inserter(f), isVowel);
std::transform(f.begin(), f.end(), std::back_inserter(t), toupper);
```

åœ¨ä½¿ç”¨ View åï¼Œä¸Šè¿°å¯ä»¥å˜æˆï¼š

```cpp
std::vector<char> letters = {'a', 'b', 'c', 'd', 'e'};

auto f = std::ranges::views::filter(letters, isVowel);
auto t = std::ranges::views::transform(f, toupper);

auto vowelUpper = std::ranges::to<std::vector<char>>(t);
```

è¿™åˆ©ç”¨äº† View çš„å¯ç»„åˆæ€§ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡ `#!cpp opera tor|` æ¥å°† View ä¸²è”åœ¨ä¸€èµ·ï¼Œè¿™å¾ˆåƒç®¡é“æ“ä½œï¼š

```cpp
using rv = std::ranges::views;
std::vector<char> letters = {'a', 'b', 'c', 'd', 'e'};
std::vector<char> upperVowel = letters | rv::filter(isVowel) | rv::transform(toupper) | rv::to<std::vector<char>>();
```

- View æ˜¯**æƒ°æ€§æ±‚å€¼/Lazy Evaluation** çš„ï¼Œè¿™æ„å‘³ç€ä¸Šä¸Šä¸ªä»£ç å—åªæœ‰åˆ°äº†æœ€åä¸€è¡Œæ‰ä¼šçœŸæ­£æ±‚å€¼ã€‚è¿™æ ·å°±å¯ä»¥å¾ˆå¤§çš„èŠ‚çº¦å†…å­˜ç©ºé—´ã€‚è¿™å¾ˆåƒ Python çš„ç”Ÿæˆå™¨ã€‚
- Range æ˜¯**æ€¥åˆ‡æ±‚å€¼/Eager Evaluation** çš„ï¼Œè¿™æ„å‘³ç€ `#!cpp std::ranges::sort(v);` ä¼šç«‹åˆ»æ“ä½œã€‚`std::ranges` æ˜¯æ—§çš„ STL ç®—æ³•çš„é‡æ–°åŒ…è£…ã€‚

> [PPT ä¸Šæåˆ°çš„ä¸€ä¸ªå°é—®é¢˜](https://www.fluentcpp.com/2019/02/12/the-terrible-problem-of-incrementing-a-smart-iterator/)

C++26 ç”šè‡³è¿˜æœ‰æ›´æ–°çš„ä¸œè¥¿ï¼Œè¿™å°±ä¸å†™äº†ã€‚

## Lecture 11ï¼šè¿ç®—ç¬¦é‡è½½

å›å¿†ï¼š`#!cpp std::map` éœ€è¦ `#!cpp operator<` æ¥æ¯”è¾ƒé”®å€¼ï¼Œè¿™æ˜¯å› ä¸ºå…¶å†…éƒ¨ä½¿ç”¨äºŒå‰æœç´¢æ ‘å®ç°ï¼Œéœ€è¦æ¯”è¾ƒé”®å€¼æ¥ç¡®å®šæ’å…¥ä½ç½®ã€‚ä½†æ˜¯ä½¿ç”¨æ¨¡ç‰ˆåŒ–çš„ `min` å…¶å®æ˜¯ä¸æ–¹ä¾¿çš„ã€‚è¿™å°±è¦æ±‚æˆ‘ä»¬å¯¹ä¸åŒçš„ç±»å®šä¹‰åºå…³ç³»ï¼Œä¹Ÿå°±æ˜¯ç»™å‡º `#!cpp operator<` çš„å®šä¹‰ã€‚

è¿ç®—ç¬¦å…è®¸æˆ‘ä»¬ä¼ è¾¾å‡½æ•°ä¸èƒ½ä¼ è¾¾çš„ã€å…³äºå¯¹è±¡çš„è¯­ä¹‰ã€‚ä½ ä»¬ `min` å¯ä»¥ä¼ è¾¾åºå…³ç³»å—ï¼Ÿ
> Operators allow you to convey meaning about types that functions don't.

```cpp
class StudentID {
   private:
    std::string name;
    std::string sunet;
    int idNumber;

   public:
    StudentID(const std::string &name, const std::string &sunet, int idNumber)
        : name(name), sunet(sunet), idNumber(idNumber) {}
    bool operator<(const StudentID &rhs) const { return idNumber < rhs.idNumber; }
    friend bool operator==(const StudentID &lhs, const StudentID &rhs);
};

bool operator>(const StudentID &lhs, const StudentID &rhs) { return rhs < lhs; }
bool operator==(const StudentID &lhs, const StudentID &rhs) {
    return lhs.idNumber == rhs.idNumber && lhs.name == rhs.name && lhs.sunet == rhs.sunet;
}
```

- æˆå‘˜é‡è½½ï¼šå¦‚ä¸Šé¢å¯¹ `#!cpp operator<` çš„é‡è½½ï¼Œç¬¬ä¸€ä¸ªæ“ä½œæ•°å°±æ˜¯è°ƒç”¨å½“å‰è¿ç®—ç¬¦çš„å¯¹è±¡çš„å¼•ç”¨ï¼›
- éæˆå‘˜é‡è½½ï¼šå¦‚ä¸Šé¢å¯¹ `#!cpp operator==` å’Œ `#!cpp operator>` çš„é‡è½½ï¼Œä¼ å…¥çš„ç¬¬ä¸€ä¸ªæ“ä½œæ•°æ˜¯è¿ç®—ç¬¦å·¦ä¾§çš„å¯¹è±¡çš„å¼•ç”¨ï¼Œç¬¬äºŒä¸ªæ˜¯å³ä¾§çš„ã€‚
- éæˆå‘˜é‡è½½æ›´è¢« STL åçˆ±ï¼Œå¹¶ä¸”åœ¨ C++ æ›´ä¸ºå¸¸è§ï¼Œå› ä¸ºå…¶å…è®¸å·¦ä¾§çš„æ“ä½œæ•°æ˜¯ä»»æ„ç±»å‹ï¼Œå¹¶ä¸”å…è®¸é‡è½½æˆ‘ä»¬ä¸æ‹¥æœ‰çš„ç±»ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªè¿ç®—ç¬¦è®² `StudentID` å’Œä»»ä½•æˆ‘ä»¬å®šä¹‰çš„ç±»æ¯”è¾ƒã€‚
- å‹å…ƒå…è®¸éæˆå‘˜å‡½æ•°è®¿é—®å¯¹è±¡çš„ `private` æˆå‘˜ã€‚

ä¸èƒ½é‡è½½çš„è¿ç®—ç¬¦ï¼š

- `::`ï¼šä½œç”¨åŸŸè§£æè¿ç®—ç¬¦
- `.`ï¼šæˆå‘˜è®¿é—®è¿ç®—ç¬¦
- `.*`ï¼šæˆå‘˜æŒ‡é’ˆè®¿é—®è¿ç®—ç¬¦
- `? :`ï¼šä¸‰å…ƒè¿ç®—ç¬¦
- `sizeof()`ï¼šè·å–ç±»å‹æˆ–å¯¹è±¡çš„å¤§å°
- `typeid()`ï¼šè·å–ç±»å‹ä¿¡æ¯
- `cast()`ï¼šç±»å‹è½¬æ¢

å¯ä»¥é‡è½½çš„è¿ç®—ç¬¦ï¼š

<img class="center-picture" src="../assets/106L-10-1.png" width=550 />

```cpp

```cpp
class __lambda_6_18 {
   public:
    bool operator()(int x) const { return x < n; }
    __lambda_6_18(int &n) : n{_n} {}
   private: 
    int n;
};

int n = 10;
auto lessThanN = __lambda_6_18(n);
find_if(begin, end, lessThanN);
```

æˆ‘æœ‰é—®é¢˜ğŸ¤“ï¼šæˆ‘é‡è½½äº†è¿ç®—ç¬¦ `#!cpp operator()`ï¼Œå¯¹ä½¿ç”¨ `()` çš„æ„é€ å‡½æ•°æœ‰æ²¡æœ‰å½±å“ï¼Ÿ

å½“ç„¶æ˜¯æ²¡æœ‰ï¼šæ„é€ å‡½æ•°å’Œ `operator()` æ˜¯å®Œå…¨ç‹¬ç«‹çš„å‡½æ•°ã€‚é‡è½½ `operator()` ä¸ä¼šå½±å“æ„é€ å‡½æ•°çš„ä½¿ç”¨ã€‚åœ†æ‹¬å·è¯­æ³•åœ¨ä¸¤ç§æƒ…å†µä¸‹æœ‰ä¸åŒçš„å«ä¹‰ï¼š

- å¯¹ç±»åä½¿ç”¨æ—¶è¡¨ç¤ºæ„é€ å‡½æ•°è°ƒç”¨ï¼›
- å¯¹å¯¹è±¡ä½¿ç”¨æ—¶è¡¨ç¤º `operator()` è°ƒç”¨ã€‚

```cpp
class Calculator {
   public:
    Calculator(int base) : base_(base) { std::cout << "Calculator constructed\n"; }
    int operator()(int x) const { return base_ + x; }

   private:
    int base_;
};

Calculator calc(10);  // æ­£å¸¸å·¥ä½œ
int result = calc(5); // è°ƒç”¨ operator()ï¼Œè¿”å› 15
```

## Lecture 12ï¼šç‰¹æ®Šæˆå‘˜å‡½æ•°

æ¯ä¸ªç±»éƒ½é»˜è®¤æœ‰å…­ä¸ªç‰¹æ®Šçš„æˆå‘˜å‡½æ•°ï¼Œè¿™äº›æˆå‘˜å‡½æ•°åªæœ‰åœ¨è¢«è°ƒç”¨çš„æƒ…å†µä¸‹æ‰ä¼šè‡ªåŠ¨ç”Ÿæˆé»˜è®¤ç‰ˆæœ¬ï¼Œæˆ–è€…æˆ‘ä»¬æ˜¾å¼åœ°å®šä¹‰å®ƒä»¬ã€‚

- é»˜è®¤æ„é€ å‡½æ•°/Default Constructorï¼š`#!cpp T()`ï¼›
- ææ„å‡½æ•°/Destructorï¼š`#!cpp ~T()`ï¼›
- æ‹·è´æ„é€ å‡½æ•°/Copy Constructorï¼š`#!cpp T(const T &)`ï¼›
- æ‹·è´èµ‹å€¼è¿ç®—ç¬¦/Copy Assignment Operatorï¼š`#!cpp T& operator=(const T &)`ï¼›
- ç§»åŠ¨æ„é€ å‡½æ•°/Move Constructorï¼š`#!cpp T(T &&)`ï¼›
- ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦/Move Assignment Operatorï¼š`#!cpp T& operator=(T &&)`ã€‚

```cpp
class Widget {
   public: 
    Widget();
    Widget(const Widget &w);
    Widget& operator=(const Widget &w);
    Widget(Widget &&rhs);
    Widget& operator=(Widget &&rhs);
    ~Widget();
};

Widget widgetOne;
Widget widgetTwo = widgetOne;   // è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°
Widget widgetThree;
widgetThree = widgetOne;        // è°ƒç”¨æ‹·è´èµ‹å€¼è¿ç®—ç¬¦
```

- åœ¨å°†ä¸€ä¸ªå·²ç»å­˜åœ¨çš„å¯¹è±¡èµ‹å€¼ç»™å¦ä¸€ä¸ªçš„æ—¶å€™ï¼Œä¼šè°ƒç”¨æ‹·è´èµ‹å€¼è¿ç®—ç¬¦ï¼›
- åœ¨ä½¿ç”¨ä¸€ä¸ªå·²ç»å­˜åœ¨çš„å¯¹è±¡åˆå§‹åŒ–å¦ä¸€ä¸ªå¯¹è±¡çš„æ—¶å€™ï¼Œä¼šè°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ã€‚
- å½“ä¸€ä¸ªå¯¹è±¡å‡ºäº†ä½œç”¨åŸŸï¼Œææ„å‡½æ•°ä¼šè¢«è‡ªåŠ¨è°ƒç”¨ã€‚

å¯¹äºä¸èƒ½èµ‹å€¼çš„æˆå‘˜ï¼Œæ¯”å¦‚ `const` æˆå‘˜æˆ–è€…å¼•ç”¨æˆå‘˜ï¼Œè¿™å°±éœ€è¦ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨ï¼Œåˆå§‹åŒ–åˆ—è¡¨çš„æ•ˆç‡ä¹Ÿæ›´é«˜ã€‚

```cpp
template <typename T>
class MyClass {
    const int _constant;
    int &_reference;
   public:
    MyClass(int value, int &ref) : _constant(value), _reference(ref) {}
};
```

é»˜è®¤çš„æ‹·è´æ„é€ å‡½æ•°ä¼šæ‹·è´æ¯ä¸€ä¸ªæˆå‘˜å˜é‡ï¼ŒæŒ‰æˆå‘˜é€ä¸ªå¤åˆ¶ï¼Œä½†æ˜¯è¿œè¿œä¸è¶³å¤Ÿå¦‚æœå˜é‡æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œé‚£ä¹ˆæ‹·è´çš„åªæ˜¯æŒ‡é’ˆçš„å€¼ï¼Œè€Œä¸æ˜¯æŒ‡é’ˆæŒ‡å‘çš„å†…å®¹ï¼Œè¿™ç§æƒ…å†µè¢«ç§°ä¸ºæµ…æ‹·è´ã€‚

```cpp
template <typename T>
Vector<T>::Vector(const Vector<T> &other) 
    : _size(other._size), _capacity(other._capacity), _data(other._data) { }
```

å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬å¸Œæœ›åˆ›å»ºçš„æ‹·è´ä¸ä»…ä»…åªæ˜¯æ‹·è´æˆå‘˜å˜é‡ï¼›æ·±æ‹·è´ä¼šåˆ›å»ºä¸€ä¸ªå®Œå…¨ç‹¬ç«‹çš„å‰¯æœ¬ã€‚

```cpp
template <typename T>
Vector<T>::Vector(const Vector<T> &other) 
    : _size(other._size), _capacity(other._capacity), _data(new T[other._capacity]) {
    for (int i = 0; i < _size; i++) _data[i] = other._data[i];
}
```

æˆ‘ä»¬å¯ä»¥â€œåˆ é™¤â€ç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œé€šè¿‡ `= delete` æ¥æ˜¾å¼ç¦ç”¨å…¶åŠŸèƒ½ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ `= default` æ¥æ˜¾å¼åœ°è¦æ±‚ç¼–è¯‘å™¨ç”Ÿæˆé»˜è®¤ç‰ˆæœ¬ã€‚

```cpp
class Widget {
    Widget(const Widget &) = delete;
};
```

å…³äºç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œæœ‰ä»¥ä¸‹åŸåˆ™ï¼š

- Rule of Zeroï¼šå¦‚æœé»˜è®¤çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°èƒ½æ»¡è¶³éœ€æ±‚ï¼Œé‚£å°±ä¸è¦è‡ªå·±å®ç°ï¼Œåªåœ¨ç¼–è¯‘å™¨é»˜è®¤ç”Ÿæˆçš„ç‰ˆæœ¬ä¸èƒ½æ»¡è¶³éœ€æ±‚çš„æ—¶å€™æ‰è‡ªå·±å®ç°ã€‚å¦‚æœæˆ‘ä»¬çš„ç±»æ˜¯è‡ªç®¡ç†çš„ï¼Œå°±ä¸éœ€è¦è‡ªå®šä¹‰ç‰¹æ®Šæˆå‘˜å‡½æ•°ã€‚
- Rule of Threeï¼šå¦‚æœç±»éœ€è¦è‡ªå®šä¹‰ææ„å‡½æ•°ï¼Œé‚£ä¹ˆé€šå¸¸ä¹Ÿéœ€è¦å®šä¹‰ä¸€ä¸ªæ‹·è´æ„é€ å‡½æ•°å’Œæ‹·è´èµ‹å€¼è¿ç®—ç¬¦ã€‚å› ä¸ºæˆ‘ä»¬è‡ªå®šä¹‰ææ„å‡½æ•°æ„å‘³ç€æˆ‘ä»¬æ­£åœ¨æ‰‹åŠ¨è§£å†³åŠ¨æ€å†…å­˜åˆ†é…ï¼Œè¿™æ—¶å€™ç¼–è¯‘å™¨å°±ä¸ä¼šè‡ªåŠ¨ç”Ÿæˆé»˜è®¤çš„æ‹·è´æ„é€ å‡½æ•°å’Œæ‹·è´èµ‹å€¼è¿ç®—ç¬¦ã€‚

ä¸‹é¢å¾ˆå¤šå°±æ˜¯ä¸‹ä¸€èŠ‚ï¼šç§»åŠ¨è¯­ä¹‰çš„ä¸œè¥¿äº†ã€‚

## Lecture 13ï¼šç§»åŠ¨è¯­ä¹‰

```cpp
class Photo {
   public:
    Photo(int width, int height);
    Photo(const Photo &other);
    Photo &operator=(const Photo &other);
    ~Photo();

   private:
    int width;
    int height;
    int *data;
};

Photo::Photo(int width, int height) : width(width), height(height), data(new int[width * height]) {}

Photo::Photo(const Photo &other) : width(other.width), height(other.height),
    data(new int[other.width * other.height]) {
    std::copy(other.data, other.data + other.width * other.height, data);
}

Photo &Photo::operator=(const Photo &other) {
    if (this == &other) return *this;

    delete[] data;

    width = other.width;
    height = other.height;
    data = new int[width * height];
    std::copy(other.data, other.data + other.width * other.height, data);
    return *this;
}

Photo::~Photo() { delete[] data; }

Photo takePhoto();

int main() {
    Photo p1 = takePhoto();     // ç¼–è¯‘å™¨çš„ Return Value Optimizationï¼Œé¿å…æ‹·è´
    Photo retake(0, 0);
    retake = takePhoto();       // å…ˆæ˜¯æ‹·è´èµ‹å€¼ï¼Œç„¶åææ„
}
```

ä½†æ˜¯è¿™é‡Œçš„æ‹·è´èµ‹å€¼éå¸¸å ç”¨æ—¶é—´ï¼Œè¿™ä¸ªæ•°æ®å¯èƒ½å°±æœ‰ `width * height * 4` ä¸ªå­—èŠ‚ï¼Œå¦‚æœæ•°æ®å¾ˆå¤§ï¼Œé‚£ä¹ˆæ‹·è´èµ‹å€¼çš„æ—¶é—´å°±ä¼šå¾ˆé•¿ã€‚æˆ‘ä»¬æ›´å¸Œæœ›å°†ä¸€ä¸ªèµ„æºçš„æ‰€æœ‰æƒä»ä¸€ä¸ªå¯¹è±¡è½¬ä¸€ä¸ªå¦ä¸€ä¸ªå¯¹è±¡ï¼Œè¿™æ ·å°±é¿å…äº†æ‹·è´èµ‹å€¼ã€‚

ä½†æ˜¯ç¼–è¯‘å™¨ä»ä½•å¾—çŸ¥åº”è¯¥æ˜¯æ‹·è´è¿˜æ˜¯ç§»åŠ¨å‘¢ï¼Ÿå·¦å€¼å’Œå³å€¼çš„æ¦‚å¿µæ³›åŒ–äº† C++ ä¸­ä¸´æ—¶æ€§çš„æ¦‚å¿µï¼š

```cpp
void foo(Photo p) {
    Photo beReal = p;
    Photo instag = takePhoto();
}
```

- `beReal` æ˜¯ä¸€ä¸ªå·¦å€¼ï¼Œæ˜¯æœ‰æ˜ç¡®å†…å­˜åœ°å€çš„è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å…¶å–åœ°å€ï¼Œå¯ä»¥æ”¾åœ¨ç­‰å·å·¦è¾¹ï¼›
- `instal` æ˜¯ä¸€ä¸ªå³å€¼ï¼Œä¸´æ—¶å€¼ï¼Œæ²¡æœ‰å›ºå®šå†…å­˜åœ°å€ï¼Œä¸èƒ½å¯¹å…¶å–åœ°å€ï¼Œåªèƒ½æ”¾åœ¨ç­‰å·å³è¾¹ã€‚

å·¦å€¼çš„ç”Ÿå‘½å‘¨æœŸæ˜¯å…¶ä½œç”¨åŸŸï¼Œå³å€¼çš„ç”Ÿå‘½å‘¨æœŸæ˜¯å½“å‰è¡Œã€‚

å¦‚æœæˆ‘ä»¬æœ‰å·¦å€¼ï¼Œå‘å‡½æ•°ä¼ é€’å¼•ç”¨å°±å¯ä»¥é¿å…æ‹·è´ï¼š

```cpp
void uploadToInsta(Photo &photo);

int main() {
    Photo p1 = takePhoto();
    uploadToInsta(p1);      // No COPY here.
}
```

å¯¹äºå³å€¼ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¼ é€’å³å€¼å¼•ç”¨ `&&` æ¥é¿å…æ‹·è´ï¼š

```cpp
void uploadToInsta(Photo &&photo);

int main() {
    uploadToInsta(takePhoto());     // No COPY here.
}
```

- å·¦å€¼å¼•ç”¨ï¼š`#!cpp Type&`ï¼Œç”¨äºæŒä¹…å¯¹è±¡ï¼Œå¿…é¡»ä¿æŒå¯¹è±¡åœ¨å‡½æ•°ç»“æŸåè¿˜æœ‰æ•ˆï¼›
- å³å€¼å¼•ç”¨ï¼š`#!cpp Type&&`ï¼Œç”¨äºä¸´æ—¶å¯¹è±¡ï¼Œæˆ‘ä»¬å¯ä»¥ç§»åŠ¨å…¶èµ„æºï¼Œå¯¹è±¡å¯èƒ½æœ€ç»ˆå¤„äºæ— æ•ˆçŠ¶æ€ï¼Œä½†æ˜¯æ²¡å…³ç³»çš„ã€‚

å·¦å€¼å¼•ç”¨å’Œå³å€¼å¼•ç”¨å› æ­¤å¯ä»¥äº§ç”Ÿé‡è½½ï¼š

```cpp
Photo::Photo(const Photo &other) : width(other.width), height(other.height),
    data(new int[other.width * other.height]) {
    std::copy(other.data, other.data + other.width * other.height, data);
}

Photo::Photo(Photo &&other) : width(other.width), height(other.height), data(other.data) {
    other.data = nullptr;
}

Photo &Photo::operator=(const Photo &other) {
    if (this == &other) return *this;

    delete[] data;
    width = other.width;
    height = other.height;
    data = new int[width * height];
    std::copy(other.data, other.data + other.width * other.height, data);
    return *this;
}

Photo &Photo::operator=(Photo &&other) {
    delete[] data;
    width = other.width;
    height = other.height;
    data = other.data;
    other.data = nullptr;
    return *this;
}
```

å¼ºåˆ¶ç§»åŠ¨è¯­ä¹‰ï¼š

```cpp
void PhotoCollection::insert(const Photo &photo, int pos) {
    for (int i = size(); i > pos; i--) 
        elems[i] = elem[i - 1];
    elems[i] = pic;
}
```

è¿™æ—¶æ˜¾ç„¶ç¬¬ä¸‰è¡Œä½¿ç”¨çš„æ˜¯æ‹·è´èµ‹å€¼ï¼Œæˆ‘ä»¬å¸Œæœ›ä½¿ç”¨ç§»åŠ¨èµ‹å€¼ï¼Œè¿™æ—¶å°±éœ€è¦å¼ºåˆ¶ç§»åŠ¨è¯­ä¹‰ï¼š

```cpp
elems[i] = std::move(elem[i - 1]);
```

`#!cpp std::move` å°†å·¦å€¼è½¬æ¢ä¸ºå³å€¼ï¼Œä»è€Œè®©ç¼–è¯‘å™¨é€‰æ‹©æ­£ç¡®çš„é‡è½½ã€‚ä½†æ˜¯æˆ‘ä»¬ä»ç„¶åº”è¯¥è¶³å¤Ÿæ³¨æ„ï¼Œè¢«ç§»åŠ¨è¿‡çš„å¯¹è±¡å¤„äºæœªçŸ¥/æ— æ•ˆçŠ¶æ€ï¼Œå¯ä»¥çœ‹ä½œé‡æŒ‡é’ˆï¼Œéœ€è¦è°¨æ…å¤„ç†ã€‚

æœ€åé˜é‡Šä¸€ä¸‹ C++ çš„å‡ ä¸ªåŸåˆ™ï¼š

- Rule of One: If a class does not manage memory (or another external resource), the compiler generated versions of the SMFs are sufficient.
- Rule of Three: If a class manages external resources, we must define **copy assignment/destructor**. Or, if we need to define only one of the copy constructor/assignment and destructor, we should define all three.
- Rule of Five: If we defined copy constructor/assignment and destructor, we should also define move constructor/assignment.

## Lecture 14ï¼šOptional å’Œç±»å‹å®‰å…¨

**ç±»å‹å®‰å…¨**ï¼šå‡½æ•°ç­¾åä¿è¯å‡½æ•°è¡Œä¸ºçš„èƒ½åŠ›ï¼ˆç¼–ç¨‹è¯­è¨€é˜²æ­¢å‡ºç°ç±»å‹é”™è¯¯çš„èƒ½åŠ›ï¼‰ã€‚
> The extent to which a **function signature** guarantees the behavior of the function.

```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while(vec.back() % 2 == 1) {
        vec.pop_back();
    }
}
```

- `#!cpp vector::back()` è¿”å› `vector` çš„æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨ï¼Œå¦‚æœ `vector` ä¸ºç©ºï¼Œåˆ™è¡Œä¸ºæœªå®šä¹‰ï¼›
- `#!cpp vector::pop_back()` åˆ é™¤ `vector` çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼›
- å› æ­¤æˆ‘ä»¬ä¸èƒ½ä¿è¯è¿™ä¸ªå‡½æ•°çš„è¡Œä¸ºæ˜¯å®‰å…¨çš„ã€‚

è§£å†³ï¼šç¨‹åºå‘˜æœ‰è´£ä»»ç¡®ä¿å‰ç½®æ¡ä»¶ `vec` ä¸ä¸ºç©ºæˆç«‹ï¼š

```cpp
void removeOddsFromEnd(vector<int>& vec) {
    while (!vec.empty() && vec.back() % 2 == 1) {
        vec.pop_back();
    }
}
```

æ·±å±‚é—®é¢˜ï¼šé—®é¢˜æ¥è‡ªäº `#!cpp vector::back()`ï¼š

```cpp
valueType &vector<valueType>::back() {
    return *(begin() + size() - 1);
}
```

ä½†æ˜¯ä¸åŠ æ£€éªŒåœ°è§£å¼•ç”¨æŒ‡é’ˆï¼Œæœ‰å¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼Œæˆ‘ä»¬å¯ä»¥åŠ ä¸Šæ£€éªŒï¼š

```cpp
valueType &vector<valueType>::back() {
    if (empty()) throw std::out_of_range;
    return *(begin() + size() - 1);
}
```

è¿™ä¸ªç‰ˆæœ¬é€šè¿‡æŠ›å‡ºå¼‚å¸¸æ¥å¤„ç†ç©ºå®¹å™¨çš„æƒ…å†µï¼Œä½†ä»æœ‰æ”¹è¿›ç©ºé—´ã€‚å½“ `vec` å¹¶ä¸å­˜åœ¨æœ€åä¸€ä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¸Œæœ›è¿”å›ä¸€å®šçš„è­¦å‘Šè€Œä¸æ˜¯ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼š

```cpp
std::pair<bool, valueType&> vector<valueType>::back() {
    if(empty()) {
        return {false, valueType()};
    }
    return {true, *(begin() + size() - 1)};
}
```

æˆ‘ä»¬å¸Œæœ›è¿”å›ä¸€ä¸ª `std::pair`ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ è¡¨ç¤ºæ˜¯å¦æˆåŠŸï¼Œç¬¬äºŒä¸ªå…ƒç´ è¡¨ç¤ºè¿”å›çš„å€¼ã€‚ä½†æ˜¯ä»ç„¶å­˜åœ¨é—®é¢˜ï¼š

- è¦æ±‚ `valueType` æœ‰é»˜è®¤æ„é€ å‡½æ•°ï¼›
- å³ä½¿ `valueType` æœ‰é»˜è®¤æ„é€ å‡½æ•°ï¼Œè°ƒç”¨èµ·æ„é€ å‡½æ•°ä¹Ÿæ˜¯å¾ˆæ˜‚è´µçš„ï¼›
- å°±ç®—æˆ‘ä»¬å¿å—ä¸Šé¢ä¸¤ä¸ªé—®é¢˜ï¼Œå¦‚æœé»˜è®¤æ„é€ å‡½æ•°è¿”å›çš„å€¼æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆåœ¨ `#!cpp vec.pop_back()` çš„æ—¶å€™ï¼Œä»ç„¶ä¼šå‡ºç°æœªå®šä¹‰è¡Œä¸ºã€‚

`#!cpp std::optional` æ˜¯ä¸€ä¸ªæ¨¡ç‰ˆç±»ï¼Œå…¶è¦ä¹ˆåŒ…å«ç±»å‹ä¸º `T` çš„ä¸€ä¸ªå€¼ï¼Œè¦ä¹ˆä¸åŒ…å«ä»»ä½•å€¼ï¼ˆ`#!cpp std::nullopt`ï¼Œæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼Œå®ƒå¯ä»¥è¢«è½¬æ¢ä¸ºä»»ä½• `optional` ç±»å‹â€œç©ºå€¼â€ï¼‰ã€‚

```cpp
std::optional<int> num1 = {};   // num1 æ²¡æœ‰å€¼
num1 = 1;                       // ç°åœ¨æœ‰å€¼äº†
num1 = std::nullopt;            // åˆå˜æˆæ²¡æœ‰å€¼
```

å› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `#!cpp std::optional` æ¥è§£å†³ä¸Šé¢çš„é—®é¢˜ï¼š

```cpp
std::optional<valueType> vector<valueType>::back() {
    if(empty()) return {};
    return *(begin() + size() - 1);
}

void removeOddsFromEnd(vector<int>& vec) {
    while (vec.back() && vec.back().value() % 2 == 1) {
        vec.pop_back();
    }
}
```

`#!cpp std::optional` ç®€ä»‹ï¼š

- `#!cpp .value()`ï¼šè¿”å›åŒ…å«çš„å€¼ï¼Œå¦‚æœæ²¡æœ‰å€¼åˆ™æŠ›å‡º `#!cpp std::bad_optional_access` å¼‚å¸¸ï¼›
- `#!cpp .value_or(val)`ï¼šè¿”å›åŒ…å«çš„å€¼ï¼Œå¦‚æœæ²¡æœ‰å€¼åˆ™è¿”å›é»˜è®¤å€¼ `val`ï¼›
- `#!cpp .has_value()`ï¼šå¦‚æœåŒ…å«å€¼è¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚
- `#!cpp .and_then(f)`ï¼šå¦‚æœæœ‰å€¼åˆ™è°ƒç”¨å‡½æ•° `f()`ï¼Œå¹¶è¿”å›ç»“æœï¼Œå…¶ä¸­ `f` å¿…é¡»è¿”å› `#!cpp std::optional`ï¼Œæ— å€¼åˆ™è¿”å› `#!cpp std::nullopt`ã€‚
- `#!cpp .transform(f)`ï¼šå¦‚æœæœ‰å€¼ `value`ï¼Œåˆ™è¿”å›è°ƒç”¨ `f(value)` çš„ç»“æœï¼Œå…¶ä¸­ `f` å¿…é¡»è¿”å› `#!cpp std::optional<valueType>`ï¼Œæ— å€¼åˆ™è¿”å› `#!cpp std::nullopt`ã€‚
- `#!cpp .or_else(f)`ï¼šå¦‚æœæœ‰å€¼åˆ™è¿”å›è¯¥å€¼ï¼Œå¦åˆ™è¿”å›è°ƒç”¨ `f()` çš„ç»“æœã€‚

æ³¨æ„ï¼š

- ä¸å…è®¸ä½¿ç”¨ `#!cpp std::optional<T&>`ï¼Œå› ä¸ºå¼•ç”¨å¿…é¡»æ€»æ˜¯ç»‘å®šæœ‰æ•ˆå¯¹è±¡ï¼Œä½†æ˜¯ `#!cpp std::optional` ä¸èƒ½ä¿è¯è¿™ä¸€ç‚¹ï¼›
- æˆ‘ä»¬è¿˜æ˜¯éœ€è¦åˆ°å¤„ä½¿ç”¨ `#!cpp .value()` æ¥è·å–å€¼ï¼Œå¹¶ä¸”è¿˜ç»å¸¸å¯èƒ½å‘ç”Ÿ `#!cpp std::bad_optional_access` å¼‚å¸¸ã€‚è§£å¼•ç”¨ `#!cpp std::optional` å¦‚ `*optional` ä»ç„¶å¯èƒ½æœ‰æœªå®šä¹‰è¡Œä¸ºã€‚
- å•å­å¼/Monadicï¼šè½¯ä»¶è®¾è®¡æ¨¡å‹ï¼Œå…¶ç»“æ„ç»„åˆäº†ç¨‹åºæ®µï¼Œå¹¶å°†å®ƒä»¬çš„è¿”å›å€¼åŒ…è£…åœ¨ä¸€ä¸ªå¸¦æœ‰é¢å¤–è®¡ç®—çš„ç±»å‹ä¸­ã€‚å…è®¸æˆ‘ä»¬å°è¯•è°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œå¹¶ä¸”è¦ä¹ˆè¿”å›è®¡ç®—çš„ç»“æœï¼Œè¦ä¹ˆè¿”å›ä¸€äº›é»˜è®¤å€¼ã€‚

```cpp
void removeOddsFromEnd(vector<int>& vec) {
    auto idOdd = [](optional<int> num) {
        if (num) return num % 2 == 1;
        else return std::nullopt;
    };
    while (vec.back().and_then(idOdd)) 
        vec.pop_back();
}
```

è™½ç„¶ `#!cpp std::optional` æ¯”è¾ƒè‡ƒè‚¿å¹¶ä¸”è¿è¡Œèµ·æ¥æœ‰ç‚¹æ…¢ï¼ŒC++ æ ‡å‡†åº“ä¸­è¾ƒå°‘ä½¿ç”¨ `#!cpp std::optional`ï¼Œä½†æ˜¯åœ¨è‡ªå·±çš„åº”ç”¨ä»£ç ä¸­ï¼Œåœ¨åˆé€‚çš„åœºæ™¯ä¸‹ä½¿ç”¨ `#!cpp std::optional` æ˜¯å¾ˆå¥½çš„å®è·µï¼Œè¿™æ ·å¯ä»¥æé«˜ä»£ç çš„å®‰å…¨æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

## Lecture 15ï¼šRAII å’Œæ™ºèƒ½æŒ‡é’ˆ

å¼‚å¸¸æ˜¯å¤„ç†ä»£ç é”™è¯¯çš„ä¸€ç§æ–¹å¼ï¼Œå¼‚å¸¸å¯ä»¥è¢«æŠ›å‡º/Thrownï¼Œå¯ä»¥åœ¨ `try-catch` å—ä¸­æ•è·/Caught å¹¶ä¸”å¤„ç†å¼‚å¸¸ï¼Œå…è®¸ç¨‹åºåœ¨é‡åˆ°é”™è¯¯æ—¶ç»§ç»­æ‰§è¡Œè€Œä¸æ˜¯ç›´æ¥å´©æºƒã€‚

```cpp
try {
    // å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„ä»£ç 
} catch ([exception] e1) {
    // å¤„ç†å¼‚å¸¸
} catch ([exception] e2) {
    // å¤„ç†å¦ä¸€ä¸ªå¼‚å¸¸
} catch {
    // å¤„ç†å…¶ä½™æ‰€æœ‰å¼‚å¸¸
}
```

ä¸¾ä¸ªä¾‹å­ï¼š

```cpp
std::string returnNameCheckPawsome(Pet p) {
    if (p.type() == "Dog" || p.firstName() == "Fluffy") {
        std::cout << p.firstName() << " " << 
            p.lastName() << " is paw-some!" << '\n';
    }
    return p.firstName() + " " + p.lastName();
}
```

è‡³å°‘ 23 ä¸ªå¯èƒ½çš„æ‰§è¡Œè·¯å¾„ï¼š

- `Pet` çš„æ‹·è´æ„é€ å‡½æ•°å¯èƒ½æŠ›å‡º 1 ä¸ªå¼‚å¸¸ï¼›
- ä¸´æ—¶å­—ç¬¦ä¸²çš„æ„é€ å‡½æ•°åŠ èµ·æ¥å¯èƒ½æŠ›å‡º 5 ä¸ªå¼‚å¸¸ï¼›
- `Pet` çš„ `type()`ã€`firstName()` å’Œ `lastName()` æ–¹æ³•å¯èƒ½æŠ›å‡º 6 ä¸ªå¼‚å¸¸ï¼›
- `operator+` è¿ç®—ç¬¦é‡è½½å¯èƒ½æŠ›å‡º 10 ä¸ªå¼‚å¸¸ï¼›
- è¿”å›å­—ç¬¦ä¸²çš„æ‹·è´æ„é€ å‡½æ•°å¯èƒ½æŠ›å‡º 1 ä¸ªå¼‚å¸¸ã€‚

```cpp
std::string returnNameCheckPawsome(int petId) {
    Pet* p = new Pet(petId);
    if (p->type() == "Dog" || p->firstName() == "Fluffy") {
        std::cout << p->firstName() << " " << 
            p->lastName() << " is paw-some!" << '\n';
    }
    std::string returnStr = p->firstName() + " " + p->lastName();
    delete p;
    return returnStr;
}
```

åœ¨ `#!cpp new` å’Œ `#!cpp delete` ä¹‹é—´çš„å¼‚å¸¸å°±å°†å¯¼è‡´å†…å­˜æ³„éœ²ï¼Œä¹Ÿå°±æ˜¯ `p` æ²¡æœ‰è¢«ææ„ã€‚

æœ‰å¾ˆå¤šèµ„æºéœ€è¦è·å–åé‡Šæ”¾ï¼Œä¸ä»…ä»…æ˜¯å †å†…å­˜ï¼Œè¿˜æœ‰æ–‡ä»¶ã€é”å’Œå¥—æ¥å­—ç­‰ã€‚

RAIIï¼šResource Acquisition Is Initializationï¼Œèµ„æºè·å–å³åˆå§‹åŒ–ã€‚

- ç±»ï¼ˆå¯¹è±¡ï¼‰æ‰€ä½¿ç”¨çš„æ‰€æœ‰èµ„æºéƒ½åº”è¯¥åœ¨æ„é€ å‡½æ•°ä¸­è¢«è·å–ï¼›
- ç±»ï¼ˆå¯¹è±¡ï¼‰æ‰€ä½¿ç”¨çš„æ‰€æœ‰èµ„æºéƒ½åº”è¯¥åœ¨ææ„å‡½æ•°ä¸­è¢«é‡Šæ”¾ã€‚
- èµ„æºåœ¨åˆ›å»ºä¹‹åç«‹åˆ»æœ‰ç”¨ï¼Œ å½“å¯¹è±¡ç¦»å¼€ä½œç”¨åŸŸçš„æ—¶å€™è‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°ã€‚
- èµ„æºçš„è·å–å’Œé‡Šæ”¾åº”è¯¥æ˜¯ä¸€ä½“çš„ï¼Œèµ„æºçš„é‡Šæ”¾åº”è¯¥åœ¨å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶è‡ªåŠ¨è¿›è¡Œã€‚å³èµ„æºçš„æœ‰æ•ˆæœŸ = æŒæœ‰èµ„æºçš„å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸã€‚

```cpp
ifstream input;
input.open("hamlet.txt");
input.close();
```

è¿™å°±ä¸ç¬¦åˆ RAII åŸåˆ™ï¼Œå› ä¸º `input` åœ¨æ„é€ å‡½æ•°å¤–è¢«æ‰“å¼€ï¼Œåœ¨ææ„å‡½æ•°å¤–è¢«å…³é—­ã€‚

æ™ºèƒ½æŒ‡é’ˆåŒ…è£…äº†åŸå§‹çš„æŒ‡é’ˆï¼Œé€šè¿‡ RAII åŸåˆ™è‡ªåŠ¨ç®¡ç†åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼Œä¸»è¦æœ‰è¿™ä¸‰ç§ï¼š

- `#!cpp std::unique_ptr`ï¼šç‹¬å æ‰€æœ‰æƒï¼Œä¸èƒ½è¢«å¤åˆ¶ï¼›
- `#!cpp std::shared_ptr`ï¼šå…±äº«æ‰€æœ‰æƒï¼Œå¯ä»¥è¢«å¤åˆ¶ï¼Œå½“åº•å±‚å†…å­˜è¶…å‡ºä½œç”¨åŸŸçš„æ—¶å€™ä¼šè‡ªåŠ¨ææ„ï¼›
- `#!cpp std::weak_ptr`ï¼šæ—¨åœ¨ç¼“è§£å¾ªç¯ä¾èµ–çš„æŒ‡é’ˆã€‚

`#!cpp std::unique_ptr` ä¸èƒ½è¢«å¤åˆ¶ï¼Œæƒ³è±¡ä¸€ä¸‹è¿™æ ·çš„æƒ…å†µï¼šå½“æ‹·è´å‘ç”ŸååŸæ¥æŒ‡é’ˆçš„ææ„å‡½æ•°è¢«è°ƒç”¨ï¼Œé‚£ä¹ˆæ–°æ‹·è´çš„æŒ‡é’ˆå°±ä¼šæŒ‡å‘å·²ç»é‡Šæ”¾çš„å†…å­˜ã€‚ä½†æ˜¯å¯ä»¥ä½¿ç”¨ `#!cpp std::move` æ¥è½¬ç§»æ‰€æœ‰æƒã€‚

`#!cpp std::shared_ptr` é€šè¿‡ä¸é‡Šæ”¾åº•å±‚å†…å­˜ç›´åˆ°æ‰€æœ‰å…±äº«æŒ‡é’ˆéƒ½ç¦»å¼€ä½œç”¨åŸŸçš„æ–¹å¼ï¼Œè§£å†³äº†æˆ‘ä»¬å°è¯•å¤åˆ¶ std::unique_ptr æ—¶é‡åˆ°çš„é—®é¢˜ã€‚

å¼•ç”¨è®¡æ•°è¿™ç§è®¡æ•°æ˜¯ä¸ºäº†é˜²æ­¢å†…å­˜æ³„éœ²è€Œäº§ç”Ÿçš„ã€‚åŸºæœ¬æƒ³æ³•æ˜¯å¯¹äºåŠ¨æ€åˆ†é…çš„å¯¹è±¡ï¼Œè¿›è¡Œå¼•ç”¨è®¡æ•°ï¼Œæ¯å½“å¢åŠ ä¸€æ¬¡å¯¹åŒä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨ï¼Œé‚£ä¹ˆå¼•ç”¨å¯¹è±¡çš„å¼•ç”¨è®¡æ•°å°±ä¼šå¢åŠ ä¸€æ¬¡ï¼Œæ¯åˆ é™¤ä¸€æ¬¡å¼•ç”¨ï¼Œå¼•ç”¨è®¡æ•°å°±ä¼šå‡ä¸€ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨è®¡æ•°å‡ä¸ºé›¶æ—¶ï¼Œå°±è‡ªåŠ¨åˆ é™¤æŒ‡å‘çš„å †å†…å­˜ã€‚

<img class="center-picture" src="../assets/106L-15-1.png" width=550 />

`#!cpp std::shared_ptr` èƒ½å¤Ÿè®°å½•å¤šå°‘ä¸ª `#!cpp shared_ptr` å…±åŒæŒ‡å‘ä¸€ä¸ªå¯¹è±¡ï¼Œä»è€Œæ¶ˆé™¤æ˜¾å¼çš„è°ƒç”¨ `#!cpp delete`ï¼Œå½“å¼•ç”¨è®¡æ•°å˜ä¸ºé›¶çš„æ—¶å€™å°±ä¼šå°†å¯¹è±¡è‡ªåŠ¨åˆ é™¤ã€‚æˆ‘ä»¬ä½¿ç”¨ `#!cpp std::make_shared` æ¥åˆå§‹åŒ– `#!cpp std::shared_ptr`ï¼Œå…¶åˆ›å»ºä¼ å…¥å‚æ•°ä¸­çš„å¯¹è±¡ï¼Œå¹¶è¿”å›è¿™ä¸ªå¯¹è±¡ç±»å‹çš„ `#!cpp std::shared_ptr` æŒ‡é’ˆã€‚

æˆ‘ä»¬é€šè¿‡ `#!cpp .get()` è·å–åŸå§‹æŒ‡é’ˆï¼Œé€šè¿‡ `#!cpp .reset()` é‡ç½®å½“å‰æŒ‡é’ˆçš„å¼•ç”¨è®¡æ•°å¹¶å°†å…¶é‡ç½®ä¸º `reset` çš„å‚æ•°ï¼ˆä¸åŒé‡è½½æœ‰ä¸åŒå«ä¹‰ï¼Œæ¯”å¦‚ `#!cpp .reset()` ä¼šå°†å…¶é‡ç½®ä¸ºç©ºæŒ‡é’ˆï¼‰ï¼Œå‡å°‘å¯¹è±¡çš„ä¸€ä¸ªå¼•ç”¨è®¡æ•°ï¼Œé€šè¿‡ `#!cpp .use_count()` æŸ¥çœ‹ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨è®¡æ•°ã€‚

åˆå§‹åŒ–æ™ºèƒ½æŒ‡é’ˆï¼š

```cpp
std::unique_ptr<T> uniquePtr = std::make_unique<T>();
std::shared_ptr<T> sharedPtr = std::make_shared<T>();
std::weak_ptr<T> weakPtr = sharedPtr;
```

å¯¹äºä¸‹é¢ä»£ç ï¼š

```cpp
struct A {
    std::shared_ptr<B> pointer;
    ~A() {
        std::cout << "A è¢«é”€æ¯" << std::endl;
    }
};
struct B {
    std::shared_ptr<A> pointer;
    ~B() {
        std::cout << "B è¢«é”€æ¯" << std::endl;
    }
};
int main() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a->pointer = b;
    b->pointer = a;
}
```

è¿è¡Œç»“æœå°±æ˜¯ `A` å’Œ `B` éƒ½ä¸ä¼šè¢«é”€æ¯ï¼Œè¿™æ˜¯å› ä¸º `a` å’Œ `b` å†…éƒ¨çš„ `pointer` åŒæ—¶åˆå¼ºå¼•ç”¨äº† `a` å’Œ `b`ï¼Œè¿™ä½¿å¾— `a` å’Œ `b` çš„å¼•ç”¨è®¡æ•°å‡å˜ä¸ºäº† 2ï¼Œè€Œç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œ`a` å’Œ `b` æ™ºèƒ½æŒ‡é’ˆè¢«ææ„ï¼Œå´åªèƒ½é€ æˆè¿™å—åŒºåŸŸçš„å¼•ç”¨è®¡æ•°å‡ä¸€ï¼Œè¿™æ ·å°±å¯¼è‡´äº† `a` å’Œ `b` å¯¹è±¡æŒ‡å‘çš„å†…å­˜åŒºåŸŸå¼•ç”¨è®¡æ•°ä¸ä¸ºé›¶ï¼Œè€Œå¤–éƒ¨å·²ç»æ²¡æœ‰åŠæ³•æ‰¾åˆ°è¿™å—åŒºåŸŸäº†ï¼Œä¹Ÿå°±é€ æˆäº†å†…å­˜æ³„éœ²ã€‚

è§£å†³æ–¹æ³•å°±æ˜¯ä½¿ç”¨å¼±å¼•ç”¨ `#!cpp std::weak_ptr`ï¼Œå¼±å¼•ç”¨ä¸ä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œå› æ­¤ä¸ä¼šå½±å“å¯¹è±¡çš„é‡Šæ”¾ã€‚ç¾ä¸­ä¸è¶³æ˜¯ `#!cpp std::weak_ptr` ä¸èƒ½ç›´æ¥æ“ä½œèµ„æºï¼Œå…¶æ²¡æœ‰ `*` è¿ç®—ç¬¦å’Œ `->` è¿ç®—ç¬¦ï¼Œä¸èƒ½å¯¹èµ„æºè¿›è¡Œæ“ä½œï¼Œå®ƒå¯ä»¥ç”¨äºæ£€æŸ¥ `#!cpp std::shared_ptr` æ˜¯å¦å­˜åœ¨ï¼Œå…¶ `#!cpp expired()` æ–¹æ³•èƒ½åœ¨èµ„æºæœªè¢«é‡Šæ”¾æ—¶ï¼Œä¼šè¿”å› `false`ï¼Œå¦åˆ™è¿”å› `true`ï¼›é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒä¹Ÿå¯ä»¥ç”¨äºè·å–æŒ‡å‘åŸå§‹å¯¹è±¡çš„ `#!cpp std::shared_ptr` æŒ‡é’ˆï¼Œå…¶ `#!cpp lock()` æ–¹æ³•åœ¨åŸå§‹å¯¹è±¡æœªè¢«é‡Šæ”¾æ—¶ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘åŸå§‹å¯¹è±¡çš„ `#!cpp std::shared_ptr` æŒ‡é’ˆï¼ˆ`#!cpp std::shared_ptr<T> sp = wp.lock()`ï¼‰ï¼Œè¿›è€Œè®¿é—®åŸå§‹å¯¹è±¡çš„èµ„æºï¼Œå¦åˆ™è¿”å› `nullptr`ã€‚

???- Info "`#!cpp std::unique_ptr` çš„å®ç°"

    ```cpp
    template <typename T>
    class unique_ptr {
    private:
        T *ptr{nullptr};

    public:
        unique_ptr(T *ptr) : ptr(ptr) {}

        unique_ptr(std::nullptr_t) : ptr(nullptr) {}

        unique_ptr() : unique_ptr(nullptr) {}

        T &operator*() { return *ptr; }

        const T &operator*() const { return *ptr; }

        T *operator->() { return ptr; }

        const T *operator->() const { return ptr; }

        operator bool() const { return ptr != nullptr; }

        ~unique_ptr() { delete ptr; }

        unique_ptr(const unique_ptr &other) = delete;

        unique_ptr &operator=(const unique_ptr &other) = delete;

        unique_ptr(unique_ptr &&other) : ptr(other.ptr) { other.ptr = nullptr; }

        unique_ptr &operator=(unique_ptr &&other) {
            if (this != &other) {
                delete ptr;
                ptr = other.ptr;
                other.ptr = nullptr;
            }
            return *this;
        }
    };

    template <typename T, typename... Args>
    unique_ptr<T> make_unique(Args &&...args) {
        return unique_ptr<T>(new T(std::forward<Args>(args)...));
    }
    ```

## Appendix
