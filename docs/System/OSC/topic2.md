# CPU Scheduling

## 基本概念

多道程序/Multiprogramming 的设计目标是无论何时都有进程运行，进而最大化 CPU 的利用率。分时系统的目标是在进程之间快速切换 CPU，以便用户在运行的时候可以与其进行交互。进程调度器/Process Scheduler 会在多个可用进程的集合之中选择一个可用进程到 CPU 核心上运行。

CPU 的成功调度取决于如下观察到的进程属性：进程执行包括周期性进行的 CPU 执行和 I/O 等待，进程在这两个状态之间不断切换。进程执行从 CPU 突发/CPU Burst 开始，之后 I/O 突发/I/O Burst，接着再次 CPU 突发，以此类推，最后的 CPU 突发通过系统请求结束，进程终止。

通常，大多数进程可以被分为两类：

- I/O Bound Process：花费在 I/O 上的时间多于花费在计算上的时间，只会有很少的 CPU 突发；
- CPU Bound Process：花费在计算上的时间多于花费在 I/O 上的时间，如果存在 I/O 突发，那么会很短，大多很少生成 I/O 突发。

CPU 调度需要维护进程的调度队列，进程会在不同的队列之间移动：

- 就绪队列/Ready Queue：包含所有驻留在主存中，处于就绪状态准备运行的进程；
- 等待队列/Waiting Queues：存放等待着某个事件发生的进程；
- Device Queues：存放等待某个 I/O 设备的进程。
- ...

这些队列都使用链表实现，头结点都有着两个指针，分别指向链表的第一个和最后一个 PCB 块，每个 PCB 块也包含一个指针，用于指向队列的下一个 PCB 块。

<img class="center-picture" src="../../images/img-OSC/Schedule-1.png" alt="drawing" width="500" />

就绪队列只有一个，但是等待队列一般有多个，因为等待队列等待的事件有很多种，比如等待 I/O 完成、等待子进程终止，等待中断等等：

- 发出 I/O 请求的进程就会放在 I/O 等待队列中；
- 进程可能创建一个新的子进程，这时候就放在子进程等待队列中，等待子进程终止；
- 进程可能由于中断或者时间片到期，被强制释放 CPU，这时候也被放在等待队列中。

<img class="center-picture" src="../../images/img-OSC/Schedule-2.png" alt="drawing" width="500" />

我们把多个等待执行的进程都存放在主存中，很多操作系统还有另外一种形式的调度：交换/Swap。主要思想是：有时从主存中（以及从对 CPU 的争用中）删除一个进程是有利的，这时就可以降低多道程序的度/Degree（即当前在内存中的进程数量）。这种情况下，我们将进程的当前状态保存，将其换到硬盘上，知道被调度的时候才会换入内存、恢复状态，从停止执行的地方继续执行。

Swap 其实就提到了**上下文切换/Context Switch**：举一个中断的例子，当中断发生的时候，系统需要保存当前运行在 CPU 上的进程的上下文，以便处理终断之后可以恢复上下文。进程的上下文使用 PCB 表示，包含 CPU 寄存器的值、进程的状态和内存管理信息等。通常，通过执行状态保存保存 CPU 当前状态（包含内核模式和用户模式），之后通过状态恢复恢复 CPU 当前状态。

上下文切换也分为自愿的和非自愿的：

- 当进程放弃对 CPU 的控制的时候，会发生资源上下文切换，这是因为它需要当前不可用的资源；
- 非资源上下文切换发生在 CPU 已从进程中取出的时候，比如当前时间片到期或者被更高优先级的进程抢占的时候。

<img class="center-picture" src="../../images/img-OSC/Schedule-3.png" alt="drawing" width="650" />

上图的过程就是一个上下文切换的过程，微观上看，将状态存到 PCB 和从 PCB 恢复状态的过程就是右边的过程，这也就是分派器/Dispatcher 的职责。从前一个进程暂停运行到下一个进程开始运行的时间叫做 **Dispatch Latency**。

操作系统的设计强调机制/Machanism 与策略/Policy 分离，这里谈到的机制就是分配器、队列与上下文切换，策略就是调度策略。上文基本已经阐述清楚了 CPU 调度的机制，下面我们将以几个调度策略来考虑如何设计优秀的调度策略。

## 调度准则

## 调度策略

总的来说，设计调度策略是复杂的：因为我们需要平衡不同目标，比如想要最大化吞吐量就不能有过多的上下文切换、有过少的上下文切换就会提升响应时间。同时，调度策略也不能过于复杂，这样调度时间就会变长，也会增加系统开销。

### 1. 调度策略的分类

需要进行 CPU 调度的情况可以分为下面四种：

1. 当前进程从运行状态/Running 切换到等待状态/Waiting 时；
2. 当前进程从运行状态/Running 切换到就绪状态/Ready 时；
3. 当前进程从等待状态/Waiting 切换到就绪状态/Ready 时；
4. 当前进程从运行状态/Running 切换到终止状态/Terminated 时；

而调度策略可以按照发生调度的时机进行分类：

- 非抢占式调度/Nonpreemptive Scheduling/Cooperative：只有当进程自愿放弃 CPU 的时候，才会发生调度，着眼当前 CPU 正在执行的进程，调度只有可能发生在第一种和第四种情况下，因为只有这时的调度原因是该进程自愿放弃 CPU；
- 抢占式调度/Preemptive Scheduling：进程可以被别的进程抢占执行，尽管别的进程可以继续执行下去，也就是在上面的任何时候都有可能发生调度，若以下面的优先级调度为例，有可能有某个新建的进程优先级很高，就直接把当前 CPU 上的进程抢占下来。

在非抢占调度下，如果某个进程被分配到 CPU，这个进程就会一直使用 CPU，直到它终止或等切换到等待状态。

我们认为抢占式调度是更好的，因为可以使操作系统对程序有更多的控制，尽管我们有时钟中断等手段来获得 CPU 的控制权；也可以提升系统的响应性。但是抢占式调度确是复杂的，其会引入很多有关于进程同步的话题，可以简单考虑共享数据访问/Access to shared data，内核态的抢占/Preemption while in the kernel mode，以及重要操作系统活动中的中断/Interrupts occurring during crucial OS activities 这些问题。

### 2. First-Come, First-Served (FCFS)

策略很简单：先请求 CPU 的进程会首先被分配到 CPU。FCFS 策略可以通过 FIFO 队列简单实现。下图是一个简单的例子：

<img class="center-picture" src="../../images/img-OSC/Schedule-4.png" alt="drawing" width="650" />

FCFS 的缺点是平均等待时间往往很长。并且如果进程的 CPU 突发时间变化很大，那么平均等待时间的变化也会很大。另外，**FCFS 是一种非抢占调度**，就很有可能出现一种情况：有一个长时间的 CPU 密集型进程后边跟着很多 I/O 密集型进程，这时很多端的进程都等待着一个长的进程，这种情况被称为**护航效应/Convoy Effect**。

### 3. Shortest-Job-First (SJF)

该策略将每个进程与该进程下一个 CPU 突发的长度联系起来，当 CPU 变得空闲的时候，就会选择下一个 CPU 突发时间最短的进程，如果两个进程有相同的 CPU 长度，那么就需要用 FCFS 来决定。因此这个策略有时候也被称为**最短下次 CPU 突发调度/Shortest-Next-CPU-Burst Scheduling**。

事实证明 SJF 算法确实是最优的，因为对于任意给定的一组进程，SJF 算法总是会生成最小的平均等待时间。但是 SJF 算法是不可行的，我们不能在 CPU 调度上加以实现，因为我们没有办法知道下一个 CPU 突发的长度。一种方法是使用前面观测到的 CPU 突发时间的指数平均值来预测下一个 CPU 突发的长度。

$$
\tau_{n+1} = \alpha t_n + (1 - \alpha) \tau_n
$$

这里的 $\tau_{n+1}$ 是预测的下一个 CPU 突发的长度，$t_n$ 是实际观测到的 CPU 突发的长度，$\tau_n$ 是上一个预测的 CPU 突发的长度，$\alpha$ 是一个在 0 和 1 之间的值，控制我们所预测的近期和过去历史的相对权重，通常是 0.5，表示最近的历史和过去的历史同等重要。

上个式子通过递归定义，将其 $\tau_n$ 展开，可以得到

$$
\tau_{n+1} = \alpha t_n + (1 - \alpha) \alpha t_{n-1} + (1 - \alpha)^2 \alpha t_{n-2} + \cdots + (1 - \alpha)^{n+1} \tau_0
$$

SJF 算法有两种形式：抢占的和非抢占的。当一个新进程到达就绪队列但是有一个进程正在执行的时候，这两种策略就产生了差别：

- 若是非抢占的 SJF，尽管可能新进程的 CPU 突发时间比当前进程**剩下**的 CPU 时间短，新进程仍然会等待当前进程执行完毕，并将新进程放在就绪队列的顶部；
- 在上面的情况下，抢占 SJF 调度会停止当前进程，将新进程放在 CPU 上执行。抢占 CPU 调度有时候也被称为**最短剩余时间优先调度/Shortest-Remaining-Time-First Scheduling**。

### 4. Round-Robin (RR)

**轮转调度/Round-Robin Scheduling** 类似于 FCFS 算法，但是为了避免护航效应，轮转调度增加了抢占以切换进程。基本思想是：我们给每个进程一小段执行的时间单元，这个时间单元被称为**时间片/Time Slice** 或者**时间配额/Time Quantum**，当进程用完了时间片，就被踢下去，等待下一次调度。这时候就绪队列也就成为了一个循环队列。

具体而言，我们再次将就绪队列视为进程的 FIFO 队列，新进程添加到就绪队列的尾部，调度程序从就绪队列中选择第一个进程，将定时器设置在这个进程的时间片后中断，然后分派这个进程。接下来有可能发生两种事情：

- 进程的 CPU 突发时间短于时间片，进程在时间片结束之前自动释放 CPU，调度程序直接选择下一个进程就可以了；
- 进程的 CPU 突发事件长于时间片，那么定时器就会中断，进而中断操作系统，操作系统会让分配器进行上下文切换，将当前进程放在就绪队列的尾部，然后选择下一个进程。

### 5. Priority Scheduling

最短作业优先调度/SJF 是**优先级调度/Priority Scheduling** 的一个特例。对优先级调度而言，我们将每一个进程分配一个优先级，具有最高优先级的进程优先分配 CPU 执行。优先级可以是内部的和外部的：

- 内部的：比如一些测量数据，SJF 策略以预测的 CPU 突发时间作为优先级；
- 外部的：用户可以指定任务的重要程度。

值得注意的是，优先级其实就是在某个范围内的一个数字，但是数字大小对应的优先级是不确定的，低的数字可以对应高的或者低的优先级，并没有一个统一的标准。


### 6. Multi-Level Queue Scheduling

### 7. Multi-Level Feedback Queue Scheduling

## 多处理器调度





