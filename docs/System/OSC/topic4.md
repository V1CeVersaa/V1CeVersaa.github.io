# Deadlock

## 死锁问题

> 大多数操作系统**并不**预防或者处理死锁。很多都采用鸵鸟的解决方式——忽略死锁问题并且假装死锁从来没有在操作系统中发生过。

## 系统模型与资源分配

### 1. 系统模型

一个系统拥有优先数量的资源亟待分配给若干个竞争线程，这些资源可以分成多种类型，每种类型的资源有多个实例。资源类型很多，比如 CPU、文件和 I/O 设备等等。如果一个线程申请某一个资源类型的一个实例，那么分配这种资源类型的任何实例也可以满足申请，否则这些实例就不相同，我们也没有正确定义资源分类。类似的，信号量和互斥锁也是资源的一种，这也是现代计算机系统最常见的死锁来源。

线程在使用资源前必须请求资源，使用后必须释放资源，线程可以请求执行指定任务所需的尽可能多的资源。正常操作模式下，线程可以仅按照以下顺序使用资源：

- 申请：线程请求资源，如果申请不能立刻被允许，申请线程必须一直等待，直到资源可用。
- 使用：线程对资源进行操作。
- 释放：线程释放资源。

当线程每次使用内核管理的资源时，操作系统会检查以确保该线程已经请求并获得了资源，系统表记录每个资源是否是空闲的或者已分配的，对于每个已经分配的资源，申请表记录它被分配的线程，如果线程申请的资源正在被其他线程占用，该线程就会被添加到该资源的等待队列中。

### 2. 系统资源分配图

通过成为系统资源分配图/Resource Allocation Graph 的有向图可以精准描述死锁。系统资源分配图包括节点集合 $V = P \cup R$ 和边集合 $E$，其中 $P$ 是线程的集合，$R$ 是资源的集合，$P$ 和 $R$ 互斥，$E$ 是线程和资源之间的边。

从线程 $P_i$ 到资源 $R_j$ 的边表示线程 $P_i$ 请求资源 $R_j$，也就是**申请边/Request Edge**；从资源 $R_j$ 到线程 $P_i$ 的边表示资源 $R_j$ 分配给线程 $P_i$，也就是**分配边/Assignment Edge**。

在资源分配图上，我们使用圆表示线程，使用方块表示资源类型，由于资源类型可能有多个实例，所以矩形内的点的数量表示实例数量，申请边应该从线程指向资源类型，分配边应该从资源类型内的实例指向线程。

### 3. 死锁的条件

如果在一个系统中下面四个条件同时成立，那么就能引起死锁：

- **互斥/Mutual Exclusion**：如果一个资源必须处于非共享模式，也就是一次只有一个线程可以使用。如果另一个线程申请该资源，那么申请线程必须等到资源被释放。
- **占有并等待/Hold and Wait**：一个线程应该占有至少一个资源，并等待另一个资源，而该资源被其他线程占有。
- **非抢占/No Preemption**：资源不能被抢占，只能被线程完成任务后自愿释放。
- **循环等待/Circular Wait**：有一组等待线程 $P_1, P_2, \cdots, P_n$，其中 $P_1$ 等待 $P_2$ 占有的资源，$P_2$ 等待 $P_3$ 占有的资源，$P_n$ 等待 $P_1$ 占有的资源。

只有所有四个条件同时满足才会出现死锁。四个条件并不是完全独立的，其中循环等待蕴含着占有并等待。

放到资源分配图上看：如果资源分配图上没有环，系统就不处于死锁状态；若有环，系统**可能会也可能不会**处于死锁状态。

- 如果每个资源类型刚好有一个实例，那么有环就等价于死锁；
- 如果环上只涉及一组资源类型，且环上的资源类型每个就只有一个实例，那么有环就等价于死锁；
- 如果环上的资源类型有多个实例，那么有环不一定等价于死锁，某个资源实例可以释放并且分配给环上的其他线程，这就盘活了系统。

???- Example "死锁的例子"

    第一个的确锁上了，第二个没锁上，等 $P_2$ 或 $P_4$ 释放资源就活了。

    <img src="../../images/img-OSC/Deadlock-2.png" alt="drawing" width="550" />
    <img src="../../images/img-OSC/Deadlock-3.png" alt="drawing" width="550" />

## 死锁的处理

### 1. 死锁预防

死锁预防/Deadlock Prevention 方案确保至少有一个死锁的必要条件不成立，这些方法通过限制如何申请资源的方法预防死锁。

1. 互斥：
2. 占有并等待：
3. 非抢占：如果一个线程申请一个另一个不能立刻分配的资源，那么其持有的所有资源都可以被抢占（也就是隐式释放掉所有资源），被抢占的资源被加到它等待的资源列表上，只有当线程获得其原有资源和所有等待资源的时候，其才可以继续执行。问题还是很大，这通常用于状态可以轻松保存和稍后恢复的资源，比如 CPU 寄存器，但是对于诸如信号量和互斥锁之类的资源**不能应用**。
4. 循环等待：对所有资源类型进行完全排序，要求每个进程按照递增顺序申请资源。若是进程申请了某个资源，那么其应该先释放持有的比该资源更高序的所有资源，在此之后申请该资源。如果申请同一资源的多个实例，需要同时申请所有实例。很多操作系统都实现了这个方案，但是如果程序员不听话，这个方案也是无效的，这种方法也可能影响资源利用率。

解决循环等待的方案本身没有问题，除了程序员的问题和利用率的问题之外，还有一个就是很多场合下并不能完全排序资源。并且开发排序或层级结构本身并不能防止死锁；如果可以动态获取锁，那么加强锁排序并不能保证防止死锁。

### 2. 死锁避免

死锁避免/Deadlock Avoidance 要求操作系统事先得到有关线程申请资源和使用资源的额外信息，有了这些信息，系统可以确定对于每个申请，线程是否应该等待。

### 3. 死锁检测

### 4. 死锁恢复

